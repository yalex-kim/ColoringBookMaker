<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>컬러링북 메이커 - AI 이미지 생성 포함</title>
    <link rel="stylesheet" href="./styles/main.css">
    
    <!-- OpenCV.js 리소스 미리 로딩 힌트 -->
    <link rel="preconnect" href="https://docs.opencv.org">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="dns-prefetch" href="https://docs.opencv.org">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://unpkg.com">
    <script>
        // OpenCV.js 안정적 로딩 시스템
        let openCvLoadAttempts = 0;
        const maxRetries = 5; // GitHub Pages에서는 더 많은 재시도 허용
        let openCvLoadTimeout;
        
        // 더 다양한 CDN과 경량 버전 포함
        const opencvUrls = [
            'https://cdn.jsdelivr.net/npm/opencv.js@4.8.0/opencv.js',
            'https://unpkg.com/opencv.js@4.8.0/opencv.js',
            'https://docs.opencv.org/4.8.0/opencv.js',
            'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.8.0-release.1/opencv.js',
            'https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.8.0/opencv.js'
        ];
        
        function loadOpenCV() {
            return new Promise(async (resolve, reject) => {
                // OpenCV가 이미 로드되어 있는지 확인
                if (typeof cv !== 'undefined' && cv.Mat) {
                    resolve();
                    return;
                }
                
                // 글로벌 콜백을 미리 설정 (OpenCV.js가 참조함)
                window.cv = window.cv || {};
                window.cv.onRuntimeInitialized = function() {
                    console.log('OpenCV runtime 초기화 완료');
                };
                
                // 처음 3개는 병렬로 시도 (빠른 로딩), 실패하면 순차 시도
                try {
                    console.log('OpenCV 병렬 로딩 시도 중...');
                    updateOpenCVStatus('loading', 'OpenCV 로딩 중... (고속 모드)');
                    
                    // 처음 3개 CDN을 동시에 시도
                    const parallelPromises = opencvUrls.slice(0, 3).map((url, index) => 
                        loadFromUrl(url).then(() => {
                            console.log(`OpenCV 병렬 로딩 성공: CDN ${index + 1}`);
                            return url;
                        })
                    );
                    
                    await Promise.race(parallelPromises);
                    console.log('OpenCV 병렬 로딩 완료');
                    resolve();
                    return;
                    
                } catch (parallelError) {
                    console.warn('병렬 로딩 실패, 순차 로딩으로 전환:', parallelError.message);
                    
                    // 병렬 실패시 나머지 CDN들을 순차적으로 시도
                    for (let i = 3; i < opencvUrls.length; i++) {
                        try {
                            console.log(`OpenCV CDN 순차 시도 ${i + 1}/${opencvUrls.length}: ${opencvUrls[i]}`);
                            updateOpenCVStatus('loading', `OpenCV 로딩 중... CDN ${i + 1}/${opencvUrls.length}`);
                            
                            await loadFromUrl(opencvUrls[i]);
                            console.log(`OpenCV CDN ${i + 1} 로드 성공`);
                            resolve();
                            return;
                        } catch (error) {
                            console.warn(`OpenCV CDN ${i + 1} 실패:`, error.message);
                            if (i === opencvUrls.length - 1) {
                                reject(new Error('모든 OpenCV CDN 로드 실패'));
                            }
                            // 다음 CDN으로 넘어가기 전 잠깐 대기
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }
            });
        }
        
        function loadFromUrl(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                
                // 캐시 버스팅을 위한 타임스탬프 추가
                const cacheBuster = Date.now();
                script.src = `${url}?v=${cacheBuster}`;
                
                // 30초 타임아웃 설정 (더 긴 대기)
                const timeoutId = setTimeout(() => {
                    script.remove();
                    reject(new Error('OpenCV.js 로딩 타임아웃'));
                }, 30000);
                
                script.onload = () => {
                    clearTimeout(timeoutId);
                    console.log('OpenCV.js 스크립트 로드 완료');
                    resolve();
                };
                
                script.onerror = () => {
                    clearTimeout(timeoutId);
                    script.remove();
                    reject(new Error('OpenCV.js 로드 실패'));
                };
                
                document.head.appendChild(script);
            });
        }
        
        async function initOpenCV() {
            openCvLoadAttempts++;
            
            try {
                updateOpenCVStatus('loading', `OpenCV.js 로딩 중... (${openCvLoadAttempts}/${maxRetries})`);
                
                await loadOpenCV();
                
                // OpenCV 완전 초기화 대기 (GitHub Pages 환경을 위해 더 관대한 설정)
                await new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 200; // 20초 대기 (GitHub Pages는 더 느림)
                    
                    const checkReady = () => {
                        attempts++;
                        
                        try {
                            // 기본적인 cv 객체 존재 확인 (더 관대한 검사)
                            if (typeof cv !== 'undefined' && cv.Mat) {
                                
                                // 실제로 Mat 생성이 가능한지 테스트 (더 간단한 테스트)
                                try {
                                    const testMat = new cv.Mat();
                                    if (testMat && !testMat.empty()) {
                                        testMat.delete();
                                        console.log('OpenCV 초기화 완료 확인됨');
                                        resolve();
                                        return;
                                    } else {
                                        testMat.delete();
                                    }
                                } catch (matError) {
                                    console.log(`Mat 생성 테스트 실패 (시도 ${attempts}):`, matError);
                                    
                                    // Mat 생성 실패해도 기본 함수들이 있으면 일단 진행
                                    if (cv.imread && cv.cvtColor && cv.Canny) {
                                        console.log('기본 OpenCV 함수들은 사용 가능, 계속 진행');
                                        resolve();
                                        return;
                                    }
                                }
                            }
                            
                            if (attempts >= maxAttempts) {
                                reject(new Error(`OpenCV 초기화 타임아웃 (${attempts} 시도)`));
                                return;
                            }
                            
                            setTimeout(checkReady, 100);
                        } catch (error) {
                            console.log(`OpenCV 초기화 확인 중 오류 (시도 ${attempts}):`, error);
                            if (attempts >= maxAttempts) {
                                reject(error);
                                return;
                            }
                            setTimeout(checkReady, 100);
                        }
                    };
                    
                    // 글로벌 초기화 콜백은 이미 loadOpenCV에서 설정됨
                    
                    checkReady();
                });
                
                onOpenCvReady();
                
            } catch (error) {
                console.error(`OpenCV 로딩 시도 ${openCvLoadAttempts} 실패:`, error);
                
                if (openCvLoadAttempts < maxRetries) {
                    updateOpenCVStatus('retry', `재시도 중... (${openCvLoadAttempts + 1}/${maxRetries})`);
                    setTimeout(() => initOpenCV(), 2000); // 2초 후 재시도
                } else {
                    updateOpenCVStatus('failed', 'OpenCV.js 로드 실패 - 기본 알고리즘 사용');
                    console.warn('OpenCV.js 로드 실패. 기본 이미지 처리 알고리즘을 사용합니다.');
                }
            }
        }
        
        function updateOpenCVStatus(status, message) {
            const statusElements = document.querySelectorAll('.opencv-status');
            statusElements.forEach(el => {
                el.textContent = message;
                el.className = 'opencv-status';
                
                switch(status) {
                    case 'loading':
                        el.style.color = '#ff9800';
                        el.textContent = '⏳ ' + message;
                        break;
                    case 'retry':
                        el.style.color = '#2196F3';
                        el.textContent = '🔄 ' + message;
                        break;
                    case 'failed':
                        el.style.color = '#f44336';
                        el.textContent = '⚠️ ' + message;
                        el.innerHTML += '<br><button onclick="retryOpenCV()" style="font-size:0.8em; margin-top:5px; padding:2px 8px; background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer;">다시 시도</button>';
                        break;
                    case 'success':
                        el.style.color = 'green';
                        el.textContent = '✅ ' + message;
                        break;
                }
            });
        }
        
        function retryOpenCV() {
            openCvLoadAttempts = 0;
            initOpenCV();
        }
        
        // 페이지 로드 후 OpenCV 초기화
        document.addEventListener('DOMContentLoaded', () => {
            initOpenCV();
        });
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>컬러링북 메이커</h1>
            <p>사진을 업로드하거나 웹에서 수집하거나 AI로 최적화하여 컬러링북으로 변환해보세요!</p>
        </div>

        <!-- 모드 선택 탭 -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="upload" data-short="📁 업로드">
                📁 파일 업로드
            </button>
            <button class="mode-tab" data-mode="web" data-short="🌐 웹수집">
                🌐 웹 이미지 수집
            </button>
            <button class="mode-tab" data-mode="ai" data-short="🤖 AI생성">
                🤖 AI 이미지 생성
            </button>
        </div>

        <!-- 파일 업로드 모드 -->
        <div id="upload-mode" class="mode-content active">
            <div class="upload-section">
                <div class="upload-box" id="uploadBox">
                    <div class="upload-icon">📁</div>
                    <h3>이미지 파일 업로드</h3>
                    <p>클릭하거나 파일을 드래그해서 업로드하세요</p>
                    <p style="font-size: 0.9em; color: #888;">여러 파일 선택 가능 • 추가 업로드 시 기존 이미지 유지</p>
                    <p class="file-info">지원 형식: JPG, PNG, GIF, WEBP</p>
                    <input type="file" id="fileInput" accept="image/*" multiple hidden>
                </div>
                
                <!-- 업로드된 파일 작업 공간 (갤러리 + 미리보기) -->
                <div id="uploadWorkspace" class="web-workspace" style="display: none;">
                    <div class="workspace-container">
                        <!-- 왼쪽: 업로드된 이미지 갤러리 (1/3) -->
                        <div class="gallery-panel">
                            <div class="gallery-header">
                                <h3>📁 업로드된 이미지들</h3>
                                <p id="uploadImageCount" style="color: #888; font-size: 0.9em; margin-bottom: 8px;">업로드된 이미지 없음</p>
                                <p style="color: #666; margin: 0; font-size: 0.9em;">원하는 이미지를 클릭하여 선택하세요</p>
                            </div>
                            <div class="gallery-scrollable">
                                <div id="uploadImageGrid" class="image-grid-compact"></div>
                            </div>
                        </div>

                        <!-- 오른쪽: 선택된 이미지 미리보기 및 변환 (2/3) -->
                        <div class="preview-panel">
                            <!-- 선택된 이미지 미리보기 -->
                            <div id="uploadSelectedImagePreview" class="selected-preview" style="display: none;">
                                <h3>📷 선택된 이미지</h3>
                                <div class="image-display">
                                    <img id="uploadSelectedImage" alt="선택된 이미지">
                                </div>
                            </div>

                            <!-- 업로드 이미지 설정 옵션 -->
                            <div id="uploadControlsSection" class="web-controls-section" style="display: none;">
                                <h3>⚙️ 변환 설정</h3>
                                <div class="controls-grid-compact">
                                    <div class="control-group">
                                        <div class="opencv-status" style="font-size: 0.8em; color: orange; margin-bottom: 5px;">OpenCV.js 로딩 중...</div>
                                        <label for="uploadThreshold">윤곽선 민감도:</label>
                                        <div class="slider-group">
                                            <input type="range" id="uploadThreshold" min="50" max="200" value="90">
                                            <span id="uploadThresholdValue">90</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadLineWidth">선 굵기:</label>
                                        <div class="slider-group">
                                            <input type="range" id="uploadLineWidth" min="1" max="5" value="1">
                                            <span id="uploadLineWidthValue">1</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadPaperSize">📄 종이 사이즈:</label>
                                        <select id="uploadPaperSize">
                                            <option value="a4">A4 (210×297mm)</option>
                                            <option value="a5">A5 (148×210mm)</option>
                                            <option value="b4">B4 (250×353mm)</option>
                                            <option value="b5">B5 (176×250mm)</option>
                                            <option value="5x7">5×7 인화용 (5×7")</option>
                                            <option value="4x6">4×6 인화용 (4×6")</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadOrientation">🔄 방향:</label>
                                        <select id="uploadOrientation">
                                            <option value="portrait">세로 (Portrait)</option>
                                            <option value="landscape">가로 (Landscape)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="uploadIncludeGuide" checked>
                                            <label for="uploadIncludeGuide">🌈 색칠 가이드 포함</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="web-action-buttons">
                                    <button id="uploadProcessBtn" class="primary-btn">🎨 컬러링북 변환</button>
                                </div>
                            </div>
                            
                            <div id="uploadConvertedImageResult" class="converted-result" style="display: none;">
                                <h3>🎨 변환된 컬러링북</h3>
                                <div class="image-display">
                                    <canvas id="uploadConvertedCanvas"></canvas>
                                </div>
                                <div class="result-actions">
                                    <button id="uploadDownloadBtn" class="primary-btn">📥 다운로드</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 웹 이미지 수집 모드 -->
        <div id="web-mode" class="mode-content">
            <div class="web-section">
                <div class="input-group">
                    <input type="url" id="imageUrl" placeholder="이미지 URL을 입력하세요...">
                    <button id="loadImageBtn" class="primary-btn">이미지 로드</button>
                </div>
                <div class="url-info">
                    <p>💡 <strong>사용 팁:</strong></p>
                    <ul>
                        <li>직접 이미지 링크를 입력해주세요 (jpg, png, gif, webp)</li>
                        <li>이미지 로드에 실패하면 <strong>파일 업로드 모드</strong>를 이용해주세요.</li>
                    </ul>
                    
                    <div style="margin-top: 20px;">
                        <p style="font-weight: bold; margin-bottom: 10px;">🔗 예시 이미지 URL:</p>
                        <div class="example-urls">
                            <span class="example-url" onclick="setExampleUrl('https://pokemonkorea.co.kr/pokedex')">Pokemon Korea</span>
                            <span class="example-url" onclick="setExampleUrl('https://namu.wiki/w/Hello%20Kitty')">나무위키 헬로키티</span>
                        </div>
                        
                        <p style="font-size: 0.9em; color: #888; margin-top: 10px;">
                            ⚠️ 일부 사이트는 CORS 정책으로 인해 로드되지 않을 수 있습니다.
                        </p>
                    </div>
                </div>

                <!-- 웹 이미지 작업 공간 (갤러리 + 미리보기) -->
                <div id="webWorkspace" class="web-workspace" style="display: none;">
                    <div class="workspace-container">
                        <!-- 왼쪽: 이미지 갤러리 (1/3) -->
                        <div class="gallery-panel">
                            <div class="gallery-header">
                                <h3>🖼️ 발견된 이미지들</h3>
                                <p id="imageCount" style="color: #888; font-size: 0.9em; margin-bottom: 8px;">로딩 중...</p>
                                <p style="color: #666; margin: 0; font-size: 0.9em;">원하는 이미지를 클릭하여 선택하세요</p>
                            </div>
                            <div class="gallery-scrollable">
                                <div id="imageGrid" class="image-grid-compact"></div>
                                <div id="galleryLoading" class="gallery-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <p>이미지를 검색하는 중...</p>
                                </div>
                            </div>
                        </div>

                        <!-- 오른쪽: 선택된 이미지 미리보기 및 변환 (2/3) -->
                        <div class="preview-panel">
                            <!-- 로딩 상태 표시 -->
                            <div id="imageLoadingStatus" class="loading-status" style="display: none;">
                                <div class="loading-content">
                                    <div class="spinner-small"></div>
                                    <h3>🔄 이미지 로딩 중...</h3>
                                    <p>이미지를 불러오는 중입니다. 잠시만 기다려주세요.</p>
                                </div>
                            </div>

                            <div id="selectedImagePreview" class="selected-preview" style="display: none;">
                                <h3>📷 선택된 이미지</h3>
                                <div class="image-display">
                                    <img id="selectedImage" alt="선택된 이미지">
                                </div>
                            </div>

                            <!-- 웹 이미지 설정 옵션 -->
                            <div id="webControlsSection" class="web-controls-section" style="display: none;">
                                <h3>⚙️ 변환 설정</h3>
                                <div class="controls-grid-compact">
                                    <div class="control-group">
                                        <div class="opencv-status" style="font-size: 0.8em; color: orange; margin-bottom: 5px;">OpenCV.js 로딩 중...</div>
                                        <label for="webThreshold">윤곽선 민감도:</label>
                                        <div class="slider-group">
                                            <input type="range" id="webThreshold" min="50" max="200" value="90">
                                            <span id="webThresholdValue">90</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webLineWidth">선 굵기:</label>
                                        <div class="slider-group">
                                            <input type="range" id="webLineWidth" min="1" max="5" value="1">
                                            <span id="webLineWidthValue">1</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webPaperSize">📄 종이 사이즈:</label>
                                        <select id="webPaperSize">
                                            <option value="a4">A4 (210×297mm)</option>
                                            <option value="a5">A5 (148×210mm)</option>
                                            <option value="b4">B4 (250×353mm)</option>
                                            <option value="b5">B5 (176×250mm)</option>
                                            <option value="5x7">5×7 인화용 (5×7")</option>
                                            <option value="4x6">4×6 인화용 (4×6")</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webOrientation">🔄 방향:</label>
                                        <select id="webOrientation">
                                            <option value="portrait">세로 (Portrait)</option>
                                            <option value="landscape">가로 (Landscape)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="webIncludeGuide" checked>
                                            <label for="webIncludeGuide">🌈 색칠 가이드 포함</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="web-action-buttons">
                                    <button id="webProcessBtn" class="primary-btn">🎨 컬러링북 변환</button>
                                </div>
                            </div>
                            
                            <div id="convertedImageResult" class="converted-result" style="display: none;">
                                <h3>🎨 변환된 컬러링북</h3>
                                <div class="image-display">
                                    <canvas id="convertedCanvas"></canvas>
                                </div>
                                <div class="result-actions">
                                    <button id="downloadBtn" class="primary-btn">📥 다운로드</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI 이미지 생성 모드 -->
        <div id="ai-mode" class="mode-content">
            <div class="ai-section">
                <div class="prompt-section">
                    <h3>🤖 AI 이미지 생성</h3>
                    <div class="features-info">
                        <p><strong>🤖 AI 강화 기능:</strong></p>
                        <ul>
                            <li><strong>스마트 프롬프트 개선:</strong> 단어 몇 개만 입력해도 자동으로 최적화된 프롬프트로 변환</li>
                            <li><strong>컬러링북 특화:</strong> 컬러링북에 적합한 선명한 윤곽선과 단순한 구조로 생성</li>
                            <li><strong>다양한 스타일:</strong> 동물, 식물, 건물, 캐릭터 등 다양한 주제 지원</li>
                        </ul>
                    </div>
                    
                    <div class="input-group">
                        <textarea id="promptInput" placeholder="어떤 이미지를 생성하고 싶나요? (예: 귀여운 고양이, 성, 꽃)" rows="3"></textarea>
                        <div class="prompt-controls">
                            <button id="improvePromptBtn" class="secondary-btn">프롬프트 개선</button>
                            <button id="generateBtn" class="primary-btn">이미지 생성</button>
                        </div>
                    </div>
                    
                    <div class="example-prompts">
                        <p><strong>예시 프롬프트:</strong></p>
                        <div class="prompt-examples">
                            <span class="example-prompt" data-prompt="귀여운 강아지">귀여운 강아지</span>
                            <span class="example-prompt" data-prompt="마법의 성">마법의 성</span>
                            <span class="example-prompt" data-prompt="예쁜 꽃">예쁜 꽃</span>
                            <span class="example-prompt" data-prompt="우주 로켓">우주 로켓</span>
                        </div>
                    </div>
                </div>

                <!-- AI 이미지 결과 -->
                <div id="aiResults" class="ai-results" style="display: none;">
                    <h3>생성된 이미지</h3>
                    <div class="generated-images" id="generatedImages"></div>
                </div>
            </div>
        </div>


        <!-- 로딩 표시 -->
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
            <div class="loading-spinner">
                <div class="spinner"></div>
                <p id="loadingText">처리 중...</p>
            </div>
        </div>
    </div>

    <script>
        // 종이 사이즈 정의 (72DPI 기준)
        const paperSizes = {
            a4: { width: 595, height: 842, name: 'A4' },
            a5: { width: 420, height: 595, name: 'A5' },
            b4: { width: 708, height: 1001, name: 'B4' },
            b5: { width: 499, height: 708, name: 'B5' },
            '5x7': { width: 360, height: 504, name: '5×7' },
            '4x6': { width: 288, height: 432, name: '4×6' }
        };

        let currentImage = null;
        let openCvReady = false;

        // OpenCV.js 초기화 완료
        function onOpenCvReady() {
            console.log('OpenCV.js가 성공적으로 로드되었습니다.');
            
            try {
                // getBuildInformation은 때때로 실패할 수 있으므로 필수가 아님
                if (cv.getBuildInformation && typeof cv.getBuildInformation === 'function') {
                    try {
                        const buildInfo = cv.getBuildInformation();
                        console.log('OpenCV 버전 정보:', buildInfo);
                    } catch (buildInfoError) {
                        console.warn('OpenCV 버전 정보 호출 실패 (정상 동작에는 영향 없음):', buildInfoError.message);
                    }
                }
                
                // 메모리 초기화 테스트
                testOpenCVMemory();
                
                // 모든 검증이 완료되면 ready 상태로 설정
                if (openCvReady) { // testOpenCVMemory에서 설정됨
                    updateOpenCVStatus('success', 'OpenCV.js 로드 완료');
                    console.log('OpenCV.js 완전 초기화 완료');
                } else {
                    throw new Error('OpenCV 메모리 테스트 실패');
                }
                
            } catch (error) {
                console.error('OpenCV 초기화 중 오류:', error);
                openCvReady = false;
                updateOpenCVStatus('failed', 'OpenCV.js 초기화 실패 - 기본 알고리즘 사용');
            }
        }

        // OpenCV 메모리 상태 테스트
        function testOpenCVMemory() {
            try {
                // 작은 테스트 Mat 생성으로 메모리 상태 확인
                const testMat = new cv.Mat(10, 10, cv.CV_8UC4);
                console.log('OpenCV 메모리 테스트 성공');
                testMat.delete();
                openCvReady = true; // 테스트 성공 시에만 활성화
            } catch (error) {
                console.warn('OpenCV 메모리 테스트 실패:', error);
                openCvReady = false; // 메모리 문제가 있으면 비활성화
                throw error; // 오류를 다시 던져서 상위에서 처리
            }
        }

        // OpenCV가 안전하게 사용 가능한지 확인
        function isOpenCVSafe(width, height) {
            if (!openCvReady || typeof cv === 'undefined' || !cv.Mat) {
                return false;
            }
            
            // 이미지 크기가 너무 큰 경우 안전하지 않음
            const maxPixels = 1000000; // 1M 픽셀 제한
            if (width * height > maxPixels) {
                console.warn(`이미지가 너무 큽니다: ${width}x${height} (${width * height} 픽셀)`);
                return false;
            }
            
            try {
                // 메모리 힙 상태 확인
                const totalMemory = cv.HEAP8.length;
                const usedMemory = cv.HEAP8.buffer.byteLength;
                console.log(`OpenCV 메모리 상태: ${usedMemory}/${totalMemory} bytes`);
                
                // 메모리가 충분한지 확인 (필요한 메모리의 3배 정도 여유 필요)
                const requiredMemory = width * height * 4 * 3; // 3배 여유분
                if (totalMemory - usedMemory < requiredMemory) {
                    console.warn('OpenCV 메모리 부족');
                    return false;
                }
                
                return true;
            } catch (error) {
                console.warn('OpenCV 메모리 상태 확인 실패:', error);
                return false;
            }
        }

        // OpenCV 관련 경고 억제 (정상 동작에 영향 없는 에러들)
        window.addEventListener('error', function(event) {
            const message = event.message || '';
            const filename = event.filename || '';
            
            // OpenCV.js의 정상적인 내부 에러들은 억제
            if (filename.includes('opencv.js') && (
                message.includes('BindingError') ||
                message.includes('dynCall_') ||
                message.includes('table index') ||
                message.includes('getBuildInformation')
            )) {
                console.log('OpenCV 내부 경고 억제됨:', message);
                event.preventDefault();
                return false;
            }
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            const reason = event.reason || '';
            
            // OpenCV 관련 Promise rejection 억제
            if (typeof reason === 'string' && (
                reason.includes('OpenCV') ||
                reason.includes('BindingError') ||
                reason.includes('dynCall_')
            )) {
                console.log('OpenCV Promise rejection 억제됨:', reason);
                event.preventDefault();
            }
        });

        // Service Worker를 통한 OpenCV.js 캐싱 (선택적)
        if ('serviceWorker' in navigator && 'caches' in window) {
            // OpenCV.js를 캐시에 미리 저장
            caches.open('opencv-cache-v1').then(cache => {
                cache.addAll([
                    'https://docs.opencv.org/4.8.0/opencv.js',
                    'https://cdn.jsdelivr.net/npm/opencv.js@4.8.0/opencv.js'
                ]).catch(err => console.log('OpenCV 캐싱 실패 (정상):', err.message));
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            initApp();
        });

        function initApp() {
            setupEventListeners();
            setupSliders();
            updateTabText(); // 초기 탭 텍스트 설정
            console.log('앱 초기화 완료');
        }

        // 화면 크기에 따른 탭 텍스트 업데이트
        function updateTabText() {
            const tabs = document.querySelectorAll('.mode-tab');
            const isMobile = window.innerWidth <= 480;
            
            tabs.forEach(tab => {
                const originalText = tab.textContent.trim();
                const shortText = tab.dataset.short;
                
                if (isMobile && shortText) {
                    tab.textContent = shortText;
                } else {
                    // 원래 텍스트 복원 (data-short가 없는 경우를 위한 처리)
                    if (!tab.dataset.original) {
                        tab.dataset.original = originalText;
                    }
                    tab.textContent = tab.dataset.original;
                }
            });
        }

        function setupEventListeners() {
            // 모드 탭 전환
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    switchMode(this.dataset.mode);
                });
            });

            // 파일 업로드
            document.getElementById('uploadBox').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            document.getElementById('fileInput').addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 0) handleMultipleFiles(files);
            });

            // 드래그 앤 드롭 지원
            const uploadBox = document.getElementById('uploadBox');
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.classList.add('dragover');
            });

            uploadBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadBox.classList.remove('dragover');
            });

            uploadBox.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadBox.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                if (files.length > 0) handleMultipleFiles(files);
            });

            // 웹 이미지 로드
            document.getElementById('loadImageBtn').addEventListener('click', loadWebImage);
            
            // Enter 키로 웹 이미지 로드
            document.getElementById('imageUrl').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    loadWebImage();
                }
            });

            // 기존 버튼 이벤트 제거 (새로운 업로드 UI에서는 사용하지 않음)
            
            // 웹 컨트롤 이벤트
            const webProcessBtn = document.getElementById('webProcessBtn');
            if (webProcessBtn) {
                webProcessBtn.addEventListener('click', processWebImage);
            }

            // 업로드 컨트롤 이벤트
            const uploadProcessBtn = document.getElementById('uploadProcessBtn');
            if (uploadProcessBtn) {
                uploadProcessBtn.addEventListener('click', processUploadImage);
            }

            const uploadDownloadBtn = document.getElementById('uploadDownloadBtn');
            if (uploadDownloadBtn) {
                uploadDownloadBtn.addEventListener('click', downloadUploadResult);
            }

            // 웹 모드 다운로드 버튼 이벤트
            const webDownloadBtn = document.getElementById('downloadBtn');
            if (webDownloadBtn) {
                webDownloadBtn.addEventListener('click', downloadWebResult);
            }

            // 창 크기 변경 시 탭 텍스트 업데이트
            window.addEventListener('resize', updateTabText);
        }

        function switchMode(mode) {
            // 탭 활성화
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

            // 컨텐츠 전환
            document.querySelectorAll('.mode-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${mode}-mode`).classList.add('active');

            // 모든 UI 상태 초기화
            resetAllUIStates();

            console.log(`모드 전환: ${mode}`);
        }

        function resetAllUIStates() {
            // 현재 이미지 초기화
            currentImage = null;
            
            // 모든 섹션 숨기기
            const sectionsToHide = [
                'webWorkspace',
                'selectedImagePreview',
                'webControlsSection',
                'convertedImageResult',
                'imageLoadingStatus',
                'aiResults',
                'uploadWorkspace',
                'uploadSelectedImagePreview',
                'uploadControlsSection',
                'uploadConvertedImageResult'
            ];
            
            sectionsToHide.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'none';
                }
            });

            // 입력 필드 초기화
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.value = '';
            }
            
            const imageUrl = document.getElementById('imageUrl');
            if (imageUrl) {
                imageUrl.value = '';
            }
            
            const promptInput = document.getElementById('promptInput');
            if (promptInput) {
                promptInput.value = '';
            }

            // 웹 이미지 갤러리 초기화
            const imageGrid = document.getElementById('imageGrid');
            if (imageGrid) {
                imageGrid.innerHTML = '';
            }

            // 생성된 이미지 갤러리 초기화
            const generatedImages = document.getElementById('generatedImages');
            if (generatedImages) {
                generatedImages.innerHTML = '';
            }

            // 업로드된 이미지 갤러리 초기화
            const uploadImageGrid = document.getElementById('uploadImageGrid');
            if (uploadImageGrid) {
                uploadImageGrid.innerHTML = '';
            }

            // 업로드된 이미지 배열 초기화
            uploadedImages = [];

            // 업로드 이미지 카운트 초기화
            const uploadImageCount = document.getElementById('uploadImageCount');
            if (uploadImageCount) {
                uploadImageCount.textContent = '업로드된 이미지 없음';
            }

            console.log('모든 UI 상태 초기화 완료');
        }

        function setExampleUrl(url) {
            document.getElementById('imageUrl').value = url;
            console.log('예시 URL 설정:', url);
        }

        function loadWebImage() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) {
                alert('URL을 입력해주세요.');
                return;
            }

            console.log('웹 페이지 로드 시작:', url);

            // URL이 이미지 파일인지 확인
            if (isImageUrl(url)) {
                loadDirectImage(url);
            } else {
                scrapeWebPage(url);
            }
        }

        function isImageUrl(url) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
            const lowercaseUrl = url.toLowerCase();
            return imageExtensions.some(ext => 
                lowercaseUrl.includes(ext) && 
                (lowercaseUrl.endsWith(ext) || lowercaseUrl.includes(ext + '?'))
            );
        }

        function loadDirectImage(url) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                currentImage = img;
                showPreview(img);
                showControls();
                console.log('직접 이미지 로드 완료');
            };
            
            img.onerror = function() {
                alert('이미지 로드에 실패했습니다. URL을 확인해주세요.');
                console.error('직접 이미지 로드 실패:', url);
            };
            
            img.src = url;
        }

        async function scrapeWebPage(url) {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');

            // 워크스페이스 표시 및 로딩 표시
            showWebWorkspace();
            if (galleryLoading) {
                galleryLoading.style.display = 'block';
            }
            imageGrid.innerHTML = '';

            // 특정 사이트의 경우 직접 이미지 URL 제공
            if (url.includes('pokemonkorea.co.kr')) {
                showPokemonImages();
                return;
            }

            try {
                // 기존 사이트와 동일한 방식 사용
                const proxyUrl = 'https://api.allorigins.win/get?url=';
                console.log('웹페이지 로드 시작:', proxyUrl + url);
                const response = await fetch(proxyUrl + encodeURIComponent(url));
                
                if (!response.ok) {
                    throw new Error('웹사이트에 접근할 수 없습니다.');
                }

                const data = await response.json();
                const htmlContent = data.contents;
                
                // HTML 파싱하여 이미지 찾기 (기존 사이트 방식)
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                const imgElements = doc.querySelectorAll('img');
                
                const images = [];
                const baseUrlObj = new URL(url);
                const baseUrl = baseUrlObj.origin;
                
                for (let img of imgElements) {
                    let src = img.src || 
                             img.getAttribute('data-src') || 
                             img.getAttribute('data-lazy') || 
                             img.getAttribute('data-srcset') ||
                             img.getAttribute('data-original') ||
                             img.getAttribute('data-img') ||
                             img.getAttribute('data-load-src') ||
                             img.getAttribute('data-url');
                    
                    if (src) {
                        // data-srcset 처리 (첫 번째 URL만 사용)
                        if (src.includes(' ')) {
                            src = src.split(' ')[0];
                        }
                        
                        // 상대 경로를 절대 경로로 변환
                        if (src.startsWith('//')) {
                            src = 'https:' + src;
                        } else if (src.startsWith('/')) {
                            src = baseUrl + src;
                        } else if (!src.startsWith('http')) {
                            src = baseUrl + '/' + src;
                        }
                        
                        // 이미지 파일인지 확인하고 중복 제거 (50개 제한)
                        if (isValidImageSrc(src) && !images.some(item => item.url === src) && images.length < 50) {
                            images.push({
                                url: src,
                                alt: img.alt || img.title || `이미지 ${images.length + 1}`
                            });
                        }
                    }
                }
                
                if (galleryLoading) {
                    if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }
                }

                // CSS background-image도 체크
                const allElements = doc.querySelectorAll('*');
                for (let element of allElements) {
                    const computedStyle = element.style;
                    const backgroundImage = computedStyle.backgroundImage || element.getAttribute('style');
                    
                    if (backgroundImage && backgroundImage.includes('url(')) {
                        const urlMatch = backgroundImage.match(/url\(['"]?([^'"()]+)['"]?\)/);
                        if (urlMatch && urlMatch[1] && images.length < 50) {
                            let bgSrc = urlMatch[1];
                            
                            // 상대 경로를 절대 경로로 변환
                            if (bgSrc.startsWith('//')) {
                                bgSrc = 'https:' + bgSrc;
                            } else if (bgSrc.startsWith('/')) {
                                bgSrc = baseUrl + bgSrc;
                            } else if (!bgSrc.startsWith('http')) {
                                bgSrc = baseUrl + '/' + bgSrc;
                            }
                            
                            if (isValidImageSrc(bgSrc) && !images.some(item => item.url === bgSrc)) {
                                images.push({
                                    url: bgSrc,
                                    alt: `Background Image ${images.length + 1}`
                                });
                            }
                        }
                    }
                }

                if (images.length === 0) {
                    imageGrid.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">이미지를 찾을 수 없습니다.</p>';
                    return;
                }

                // 워크스페이스 표시 및 이미지 갤러리 로드
                showWebWorkspace();
                displayImageGallery(images); // 50개로 제한됨
                console.log(`${images.length}개의 이미지를 발견했습니다.`);

            } catch (error) {
                if (galleryLoading) {
                    if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }
                }
                imageGrid.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 20px;">
                        <h4>❌ 페이지 로드 실패</h4>
                        <p>웹사이트에 접근할 수 없습니다: ${error.message}</p>
                        <br>
                        <p><strong>대안:</strong></p>
                        <button onclick="showSampleImages()" class="primary-btn" style="margin-top: 10px;">
                            📷 샘플 이미지 보기
                        </button>
                    </div>
                `;
                console.error('웹 스크래핑 실패:', error);
            }
        }

        function isValidImageSrc(src) {
            if (!src || src.length < 10) return false;
            
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const lowercaseSrc = src.toLowerCase();
            
            // 이미지 확장자 확인
            const hasImageExt = imageExtensions.some(ext => 
                lowercaseSrc.includes(ext) && 
                (lowercaseSrc.endsWith(ext) || lowercaseSrc.includes(ext + '?'))
            );
            
            // 작은 아이콘이나 로고 제외
            const isSmallIcon = lowercaseSrc.includes('icon') || 
                               lowercaseSrc.includes('logo') || 
                               lowercaseSrc.includes('favicon') ||
                               lowercaseSrc.includes('thumb') ||
                               src.includes('1x1') ||
                               src.includes('16x16') ||
                               src.includes('32x32');
            
            return hasImageExt && !isSmallIcon;
        }

        function showPokemonImages() {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');
            
            if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }

            // 포켓몬 1~151 (1세대 전체) 및 인기 포켓몬들
            const pokemonData = [
                // 1세대 스타터 진화라인
                { num: '001', name: '이상해씨' }, { num: '002', name: '이상해풀' }, { num: '003', name: '이상해꽃' },
                { num: '004', name: '파이리' }, { num: '005', name: '리자드' }, { num: '006', name: '리자몽' },
                { num: '007', name: '꼬부기' }, { num: '008', name: '어니부기' }, { num: '009', name: '거북왕' },
                
                // 인기 포켓몬들
                { num: '025', name: '피카츄' }, { num: '026', name: '라이츄' },
                { num: '039', name: '푸린' }, { num: '040', name: '푸크린' },
                { num: '052', name: '나옹이' }, { num: '053', name: '페르시온' },
                { num: '054', name: '고라파덕' }, { num: '055', name: '골덕' },
                { num: '104', name: '텅구리' }, { num: '105', name: '텅구리' },
                { num: '131', name: '라프라스' }, { num: '143', name: '잠만보' },
                
                // 전설의 포켓몬
                { num: '144', name: '프리져' }, { num: '145', name: '썬더' }, { num: '146', name: '파이어' },
                { num: '150', name: '뮤츠' }, { num: '151', name: '뮤' },
                
                // 기타 인기 포켓몬들
                { num: '016', name: '구구' }, { num: '017', name: '피죤' }, { num: '018', name: '피죤투' },
                { num: '019', name: '꼬렛' }, { num: '020', name: '레트라' },
                { num: '035', name: '픽시' }, { num: '036', name: '픽시' },
                { num: '037', name: '식스테일' }, { num: '038', name: '나인테일' },
                { num: '058', name: '가디' }, { num: '059', name: '윈디' },
                { num: '063', name: '캐이시' }, { num: '064', name: '윤겔라' }, { num: '065', name: '후딘' },
                { num: '066', name: '알통몬' }, { num: '067', name: '근육몬' }, { num: '068', name: '괴력몬' },
                { num: '074', name: '꼬마돌' }, { num: '075', name: '데구리' }, { num: '076', name: '딱구리' },
                { num: '077', name: '포니타' }, { num: '078', name: '날쌩마' },
                { num: '083', name: '파오리' }, { num: '084', name: '두두' }, { num: '085', name: '두트리오' },
                { num: '090', name: '셀러' }, { num: '091', name: '파르셀' },
                { num: '092', name: '고오스' }, { num: '093', name: '고우스트' }, { num: '094', name: '팬텀' },
                { num: '095', name: '롱스톤' }, { num: '096', name: '슬리프' }, { num: '097', name: '슬리퍼' },
                { num: '098', name: '크랩' }, { num: '099', name: '킹크랩' },
                { num: '100', name: '찌리리공' }, { num: '101', name: '붐볼' },
                { num: '102', name: '아라리' }, { num: '103', name: '나시' },
                { num: '106', name: '시라소몬' }, { num: '107', name: '홍수몬' },
                { num: '108', name: '내룸벨트' }, { num: '109', name: '또가스' }, { num: '110', name: '또도가스' },
                { num: '111', name: '뿔카노' }, { num: '112', name: '코뿌리' },
                { num: '113', name: '럭키' }, { num: '114', name: '덩쿠리' },
                { num: '115', name: '캥카' }, { num: '116', name: '쏘드라' }, { num: '117', name: '시드라' },
                { num: '118', name: '콘치' }, { num: '119', name: '왕콘치' },
                { num: '120', name: '별가사리' }, { num: '121', name: '아쿠스타' },
                { num: '122', name: '마임맨' }, { num: '123', name: '스라크' },
                { num: '124', name: '루주라' }, { num: '125', name: '에레키드' }, { num: '126', name: '마그마' },
                { num: '127', name: '쁘사이저' }, { num: '128', name: '켄타로스' },
                { num: '129', name: '잉어킹' }, { num: '130', name: '갸라도스' },
                { num: '132', name: '메타몽' }, { num: '133', name: '이브이' },
                { num: '134', name: '샤미드' }, { num: '135', name: '쥬피썬더' }, { num: '136', name: '부스터' },
                { num: '137', name: '폴리곤' }, { num: '138', name: '암나이트' }, { num: '139', name: '암스타' },
                { num: '140', name: '투구' }, { num: '141', name: '투구푸스' },
                { num: '142', name: '프테라' }, { num: '147', name: '미뇨' }, { num: '148', name: '신뇨' }, { num: '149', name: '망나뇽' }
            ];

            const images = pokemonData.slice(0, 50).map(pokemon => ({
                url: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${parseInt(pokemon.num)}.png`,
                alt: pokemon.name
            }));

            displayImageGallery(images);
            console.log(`${images.length}개의 포켓몬 이미지 표시`);
        }

        function showSampleImages() {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');
            
            if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }

            // 다양한 샘플 이미지들
            const sampleImages = [
                { url: 'https://picsum.photos/300/400?random=1', alt: '풍경 1' },
                { url: 'https://picsum.photos/400/300?random=2', alt: '풍경 2' },
                { url: 'https://picsum.photos/350/350?random=3', alt: '자연 1' },
                { url: 'https://picsum.photos/300/500?random=4', alt: '자연 2' },
                { url: 'https://picsum.photos/400/400?random=5', alt: '도시 1' },
                { url: 'https://picsum.photos/350/450?random=6', alt: '도시 2' },
                { url: 'https://picsum.photos/320/380?random=7', alt: '추상 1' },
                { url: 'https://picsum.photos/380/320?random=8', alt: '추상 2' }
            ];

            showWebWorkspace();
            displayImageGallery(sampleImages);
            console.log('샘플 이미지 표시');
        }

        function showWebWorkspace() {
            const webWorkspace = document.getElementById('webWorkspace');
            if (webWorkspace) {
                webWorkspace.style.display = 'block';
            } else {
                console.error('webWorkspace 요소를 찾을 수 없습니다');
            }
        }

        function extractImagesFromHtml(html, baseUrl) {
            // 간단한 정규식으로 이미지 URL 추출
            const imgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
            const images = [];
            let match;

            while ((match = imgRegex.exec(html)) !== null) {
                let imgUrl = match[1];
                
                // 상대 URL을 절대 URL로 변환
                if (imgUrl.startsWith('//')) {
                    imgUrl = 'https:' + imgUrl;
                } else if (imgUrl.startsWith('/')) {
                    const baseUrlObj = new URL(baseUrl);
                    imgUrl = baseUrlObj.origin + imgUrl;
                } else if (!imgUrl.startsWith('http')) {
                    const baseUrlObj = new URL(baseUrl);
                    imgUrl = new URL(imgUrl, baseUrlObj.href).href;
                }

                // 이미지 파일인지 확인하고 중복 제거
                if (isImageUrl(imgUrl) && !images.some(img => img.url === imgUrl)) {
                    images.push({
                        url: imgUrl,
                        alt: match[0].match(/alt=["']([^"']*)["']/)?.[1] || 'Image'
                    });
                }
            }

            return images.slice(0, 20); // 최대 20개만 표시
        }

        function displayImageGallery(images) {
            const imageGrid = document.getElementById('imageGrid');
            if (!imageGrid) {
                console.error('imageGrid 요소를 찾을 수 없습니다');
                return;
            }
            imageGrid.innerHTML = '';

            // 최대 50개로 제한
            const limitedImages = images.slice(0, 50);
            console.log(`표시할 이미지 수: ${limitedImages.length}개 (원본: ${images.length}개)`);

            // 이미지 개수 표시 업데이트
            const imageCount = document.getElementById('imageCount');
            if (imageCount) {
                if (images.length > 50) {
                    imageCount.textContent = `${limitedImages.length}개 표시 (총 ${images.length}개 중)`;
                } else {
                    imageCount.textContent = `총 ${limitedImages.length}개 이미지`;
                }
            }

            limitedImages.forEach((imageInfo, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'gallery-image';
                
                const img = document.createElement('img');
                img.src = imageInfo.url;
                img.alt = imageInfo.alt;
                img.loading = 'lazy';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'image-info';
                infoDiv.textContent = `${index + 1}`;

                img.onload = function() {
                    console.log(`이미지 ${index + 1} 로드 완료`);
                };

                img.onerror = function() {
                    imageDiv.style.display = 'none';
                };

                imageDiv.addEventListener('click', () => {
                    selectGalleryImage(imageInfo.url);
                });

                imageDiv.appendChild(img);
                imageDiv.appendChild(infoDiv);
                imageGrid.appendChild(imageDiv);
            });
        }

        async function selectGalleryImage(imageUrl) {
            console.log('갤러리 이미지 선택:', imageUrl);
            
            // 로딩 상태 표시
            showImageLoadingStatus();
            hideImagePreview();
            hideConvertedResult();
            
            // 다양한 프록시 서비스들 시도
            const proxyServices = [
                'https://cors-anywhere.herokuapp.com/',
                'https://api.allorigins.win/raw?url=',
                'https://thingproxy.freeboard.io/fetch/',
                'https://cors.eu.org/',
                'https://api.codetabs.com/v1/proxy?quest='
            ];
            
            let proxyIndex = 0;
            
            function tryNextProxy() {
                if (proxyIndex < proxyServices.length) {
                    const proxyUrl = proxyServices[proxyIndex];
                    const proxiedImageUrl = proxyUrl + encodeURIComponent(imageUrl);
                    
                    console.log(`프록시 ${proxyIndex + 1} 시도:`, proxyUrl);
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    // 타임아웃 설정 (10초)
                    const timeout = setTimeout(() => {
                        console.log(`프록시 ${proxyIndex + 1} 타임아웃`);
                        proxyIndex++;
                        tryNextProxy();
                    }, 10000);
                    
                    img.onload = function() {
                        clearTimeout(timeout);
                        console.log('이미지 로드 성공 (프록시)');
                        currentImage = img;
                        hideImageLoadingStatus();
                        showSelectedImage(img);
                        showControls();
                    };
                    
                    img.onerror = function() {
                        clearTimeout(timeout);
                        console.log(`프록시 ${proxyIndex + 1} 실패, 다음 시도`);
                        proxyIndex++;
                        tryNextProxy();
                    };
                    
                    img.src = proxiedImageUrl;
                } else {
                    // 모든 프록시 실패 시 직접 로드 시도
                    console.log('모든 프록시 실패, 직접 로드 시도');
                    tryDirectImageLoad(imageUrl);
                }
            }
            
            tryNextProxy();
        }

        function tryDirectImageLoad(imageUrl) {
            console.log('직접 이미지 로드 시도:', imageUrl);
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            // 타임아웃 설정 (5초)
            const timeout = setTimeout(() => {
                console.log('직접 로드 타임아웃, 대체 이미지 생성');
                createFallbackImage(imageUrl);
            }, 5000);
            
            img.onload = function() {
                clearTimeout(timeout);
                console.log('직접 이미지 로드 성공');
                currentImage = img;
                hideImageLoadingStatus();
                showSelectedImage(img);
                showControls();
            };
            
            img.onerror = function() {
                clearTimeout(timeout);
                console.log('직접 로드도 실패, 대체 이미지 생성');
                createFallbackImage(imageUrl);
            };
            
            img.src = imageUrl;
        }

        function createFallbackImage(originalUrl) {
            // 이미지 로드 실패 시 대체 이미지 생성
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 400;
            canvas.height = 400;
            
            // 배경색
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 400, 400);
            
            // 테두리
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 398, 398);
            
            // 텍스트
            ctx.fillStyle = '#666';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('이미지 플레이스홀더', 200, 180);
            ctx.fillText('컬러링북으로 변환 가능', 200, 210);
            
            // URL 정보
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            const shortUrl = originalUrl.length > 50 ? originalUrl.substring(0, 50) + '...' : originalUrl;
            ctx.fillText(shortUrl, 200, 240);
            
            // Canvas를 이미지로 변환
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const img = new Image();
                
                img.onload = function() {
                    console.log('대체 이미지 생성 완료');
                    currentImage = img;
                    hideImageLoadingStatus();
                    showSelectedImage(img);
                    showControls();
                    alert('원본 이미지 로드에 실패하여 대체 이미지를 생성했습니다.\n컬러링북 변환은 정상적으로 작동합니다.');
                };
                
                img.src = url;
            });
        }

        function setupSliders() {
            // 기존 슬라이더 제거됨 - 새로운 업로드 UI에서는 각 모드별 슬라이더 사용

            // 웹 슬라이더
            const webThreshold = document.getElementById('webThreshold');
            const webThresholdValue = document.getElementById('webThresholdValue');
            const webLineWidth = document.getElementById('webLineWidth');
            const webLineWidthValue = document.getElementById('webLineWidthValue');
            
            if (webThreshold && webThresholdValue) {
                webThreshold.addEventListener('input', function() {
                    webThresholdValue.textContent = this.value;
                });
            }
            
            if (webLineWidth && webLineWidthValue) {
                webLineWidth.addEventListener('input', function() {
                    webLineWidthValue.textContent = this.value;
                });
            }

            // 업로드 슬라이더
            const uploadThreshold = document.getElementById('uploadThreshold');
            const uploadThresholdValue = document.getElementById('uploadThresholdValue');
            const uploadLineWidth = document.getElementById('uploadLineWidth');
            const uploadLineWidthValue = document.getElementById('uploadLineWidthValue');
            
            if (uploadThreshold && uploadThresholdValue) {
                uploadThreshold.addEventListener('input', function() {
                    uploadThresholdValue.textContent = this.value;
                });
            }
            
            if (uploadLineWidth && uploadLineWidthValue) {
                uploadLineWidth.addEventListener('input', function() {
                    uploadLineWidthValue.textContent = this.value;
                });
            }
        }

        let uploadedImages = []; // 업로드된 이미지들을 저장할 배열

        function handleMultipleFiles(files) {
            console.log(`${files.length}개 파일 업로드 시작`);
            let validFiles = [];

            // 파일 유효성 검사
            for (let file of files) {
                if (!file.type.startsWith('image/')) {
                    alert(`${file.name}은(는) 이미지 파일이 아닙니다.`);
                    continue;
                }

                if (file.size > 10 * 1024 * 1024) {
                    alert(`${file.name}의 파일 크기가 너무 큽니다. 10MB 이하의 파일만 업로드 가능합니다.`);
                    continue;
                }

                validFiles.push(file);
            }

            if (validFiles.length === 0) {
                return;
            }

            // 기존 업로드된 이미지들을 유지하면서 새 이미지 추가
            const uploadImageGrid = document.getElementById('uploadImageGrid');

            let loadedCount = 0;
            const totalCount = validFiles.length;

            // 각 파일을 읽어서 이미지로 변환
            validFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // 중복 파일명 체크 (같은 이름의 파일이 이미 있으면 추가 안함)
                        const existingFile = uploadedImages.find(item => item.name === file.name);
                        if (!existingFile) {
                            uploadedImages.push({
                                image: img,
                                name: file.name,
                                size: file.size,
                                dataUrl: e.target.result
                            });
                        } else {
                            console.log(`파일 ${file.name}은 이미 업로드되어 있습니다.`);
                        }

                        loadedCount++;
                        if (loadedCount === totalCount) {
                            displayUploadedImages();
                            showUploadWorkspace();
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function displayUploadedImages() {
            const uploadImageGrid = document.getElementById('uploadImageGrid');
            const uploadImageCount = document.getElementById('uploadImageCount');
            
            uploadImageGrid.innerHTML = '';
            uploadImageCount.textContent = `총 ${uploadedImages.length}개 이미지`;

            uploadedImages.forEach((imageInfo, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'gallery-image';
                
                const img = document.createElement('img');
                img.src = imageInfo.dataUrl;
                img.alt = imageInfo.name;
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'image-info';
                infoDiv.textContent = `${index + 1}`;

                imageDiv.addEventListener('click', () => {
                    selectUploadedImage(imageInfo);
                });

                imageDiv.appendChild(img);
                imageDiv.appendChild(infoDiv);
                uploadImageGrid.appendChild(imageDiv);
            });

            console.log(`${uploadedImages.length}개 업로드된 이미지 표시 완료`);
        }

        function showUploadWorkspace() {
            const uploadWorkspace = document.getElementById('uploadWorkspace');
            if (uploadWorkspace) {
                uploadWorkspace.style.display = 'block';
                console.log('업로드 워크스페이스 표시');
            }
        }

        function selectUploadedImage(imageInfo) {
            console.log('업로드된 이미지 선택:', imageInfo.name);
            currentImage = imageInfo.image;
            
            // 선택된 이미지 미리보기 표시
            const uploadSelectedImagePreview = document.getElementById('uploadSelectedImagePreview');
            const uploadSelectedImage = document.getElementById('uploadSelectedImage');
            const uploadControlsSection = document.getElementById('uploadControlsSection');
            
            if (uploadSelectedImagePreview && uploadSelectedImage) {
                uploadSelectedImage.src = imageInfo.dataUrl;
                uploadSelectedImagePreview.style.display = 'block';
                console.log('선택된 업로드 이미지 표시됨');
            }

            // 컨트롤 섹션 표시
            if (uploadControlsSection) {
                uploadControlsSection.style.display = 'block';
                console.log('업로드 컨트롤 섹션 표시됨');
            }
        }

        function processUploadImage() {
            if (!currentImage) {
                alert('이미지를 먼저 선택해주세요.');
                return;
            }

            console.log('업로드 이미지 처리 시작');

            try {
                // 업로드 컨트롤에서 설정값 가져오기
                const threshold = parseInt(document.getElementById('uploadThreshold').value);
                const lineWidth = parseInt(document.getElementById('uploadLineWidth').value);
                const paperSize = document.getElementById('uploadPaperSize').value;
                const orientation = document.getElementById('uploadOrientation').value;
                const includeGuide = document.getElementById('uploadIncludeGuide').checked;

                console.log('설정값:', { threshold, lineWidth, paperSize, orientation, includeGuide });

                // 종이 사이즈에 맞게 캔버스 크기 조정
                const paper = paperSizes[paperSize];
                if (!paper) {
                    console.error('종이 사이즈를 찾을 수 없습니다:', paperSize);
                    return;
                }

                let canvasWidth, canvasHeight;
                
                if (orientation === 'landscape') {
                    canvasWidth = paper.height;
                    canvasHeight = paper.width;
                } else {
                    canvasWidth = paper.width;
                    canvasHeight = paper.height;
                }

                const canvas = document.getElementById('uploadConvertedCanvas');
                if (!canvas) {
                    console.error('uploadConvertedCanvas 요소를 찾을 수 없습니다');
                    return;
                }

                const ctx = canvas.getContext('2d');
                
                // 이미지 비율에 맞게 크기 조정
                const imgRatio = currentImage.width / currentImage.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgRatio > canvasRatio) {
                    drawWidth = canvasWidth * 0.9; // 여백 10%
                    drawHeight = drawWidth / imgRatio;
                    offsetY = (canvasHeight - drawHeight) / 2;
                    offsetX = canvasWidth * 0.05;
                } else {
                    drawHeight = canvasHeight * 0.9; // 여백 10%
                    drawWidth = drawHeight * imgRatio;
                    offsetX = (canvasWidth - drawWidth) / 2;
                    offsetY = canvasHeight * 0.05;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // 흰색 배경
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // 이미지 그리기
                ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);

                // 이미지 처리
                const imageData = ctx.getImageData(offsetX, offsetY, drawWidth, drawHeight);
                let processedData;
                
                try {
                    processedData = applyImageProcessing(imageData, threshold, lineWidth);
                    console.log('이미지 처리 성공');
                } catch (processingError) {
                    console.error('이미지 처리 실패, 기본 처리 시도:', processingError);
                    // 처리 실패시 기본 처리를 직접 호출
                    processedData = applyBasicProcessing(imageData, threshold, lineWidth);
                    console.log('기본 처리로 완료');
                }
                
                // 처리된 데이터가 유효한지 확인
                if (processedData && processedData.data && processedData.width && processedData.height) {
                    ctx.putImageData(processedData, offsetX, offsetY);
                    console.log('처리된 이미지 표시 완료');
                } else {
                    console.error('처리된 데이터가 유효하지 않습니다:', processedData);
                    throw new Error('이미지 처리 결과가 유효하지 않습니다');
                }

                // 색칠 가이드 추가
                if (includeGuide) {
                    addColoringGuide(ctx, canvasWidth, canvasHeight, currentImage, paper.name, orientation);
                }

                // 변환된 결과 표시
                const resultSection = document.getElementById('uploadConvertedImageResult');
                if (resultSection) {
                    resultSection.style.display = 'block';
                    
                    // 결과 섹션으로 부드럽게 스크롤
                    setTimeout(() => {
                        resultSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                }

                console.log('업로드 이미지 처리 완료');
            } catch (error) {
                console.error('업로드 이미지 처리 중 오류:', error);
                alert('이미지 처리 중 오류가 발생했습니다: ' + error.message);
            }
        }

        function downloadUploadResult() {
            const canvas = document.getElementById('uploadConvertedCanvas');
            if (!canvas) {
                alert('처리된 이미지가 없습니다.');
                return;
            }

            const paperSize = document.getElementById('uploadPaperSize').value;
            const orientation = document.getElementById('uploadOrientation').value;
            const link = document.createElement('a');
            link.download = `coloring-book-upload-${paperSize}-${orientation}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            console.log('업로드 결과 다운로드 완료');
        }

        function downloadWebResult() {
            const canvas = document.getElementById('convertedCanvas');
            if (!canvas) {
                alert('처리된 이미지가 없습니다.');
                return;
            }

            const paperSize = document.getElementById('webPaperSize').value;
            const orientation = document.getElementById('webOrientation').value;
            const link = document.createElement('a');
            link.download = `coloring-book-web-${paperSize}-${orientation}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            console.log('웹 결과 다운로드 완료');
        }

        function handleFile(file) {
            // 기존 단일 파일 처리 함수는 이제 handleMultipleFiles를 호출
            handleMultipleFiles([file]);
        }

        // showPreview 함수 제거됨 - 새로운 갤러리 UI 사용

        function showImageLoadingStatus() {
            const loadingStatus = document.getElementById('imageLoadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'block';
                console.log('이미지 로딩 상태 표시');
            }
        }

        function hideImageLoadingStatus() {
            const loadingStatus = document.getElementById('imageLoadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'none';
                console.log('이미지 로딩 상태 숨김');
            }
        }

        function hideImagePreview() {
            const selectedImagePreview = document.getElementById('selectedImagePreview');
            if (selectedImagePreview) {
                selectedImagePreview.style.display = 'none';
            }
        }

        function hideConvertedResult() {
            const convertedResult = document.getElementById('convertedImageResult');
            const webControlsSection = document.getElementById('webControlsSection');
            
            if (convertedResult) {
                convertedResult.style.display = 'none';
            }
            if (webControlsSection) {
                webControlsSection.style.display = 'none';
            }
        }

        function showSelectedImage(img) {
            const selectedImagePreview = document.getElementById('selectedImagePreview');
            const selectedImage = document.getElementById('selectedImage');
            const webControlsSection = document.getElementById('webControlsSection');
            
            if (selectedImagePreview && selectedImage) {
                selectedImage.src = img.src;
                selectedImagePreview.style.display = 'block';
                console.log('선택된 이미지 표시됨');
            } else {
                console.error('선택된 이미지 미리보기 요소를 찾을 수 없습니다');
            }

            // 웹 컨트롤 섹션 표시
            if (webControlsSection) {
                webControlsSection.style.display = 'block';
                console.log('웹 컨트롤 섹션 표시됨');
            }
        }

        function showControls() {
            // showControls 함수는 더 이상 사용하지 않음
            // 파일 업로드 모드는 새로운 갤러리 UI에서 자체적으로 컨트롤 처리
            // 웹 이미지 모드는 showSelectedImage에서 컨트롤 처리
            console.log('showControls 호출됨 - 새로운 UI에서는 각 모드별로 컨트롤 처리');
        }

        function processWebImage() {
            if (!currentImage) {
                alert('이미지를 먼저 선택해주세요.');
                return;
            }

            console.log('웹 이미지 처리 시작');

            try {
                // 웹 컨트롤에서 설정값 가져오기
                const threshold = parseInt(document.getElementById('webThreshold').value);
                const lineWidth = parseInt(document.getElementById('webLineWidth').value);
                const paperSize = document.getElementById('webPaperSize').value;
                const orientation = document.getElementById('webOrientation').value;
                const includeGuide = document.getElementById('webIncludeGuide').checked;

                console.log('설정값:', { threshold, lineWidth, paperSize, orientation, includeGuide });

                // 종이 사이즈에 맞게 캔버스 크기 조정
                const paper = paperSizes[paperSize];
                if (!paper) {
                    console.error('종이 사이즈를 찾을 수 없습니다:', paperSize);
                    return;
                }

                let canvasWidth, canvasHeight;
                
                if (orientation === 'landscape') {
                    canvasWidth = paper.height;
                    canvasHeight = paper.width;
                } else {
                    canvasWidth = paper.width;
                    canvasHeight = paper.height;
                }

                console.log('캔버스 크기:', { canvasWidth, canvasHeight });

                const canvas = document.getElementById('convertedCanvas');
                if (!canvas) {
                    console.error('convertedCanvas 요소를 찾을 수 없습니다');
                    return;
                }

                const ctx = canvas.getContext('2d');
                
                // 이미지 비율에 맞게 크기 조정
                const imgRatio = currentImage.width / currentImage.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgRatio > canvasRatio) {
                    drawWidth = canvasWidth * 0.9; // 여백 10%
                    drawHeight = drawWidth / imgRatio;
                    offsetY = (canvasHeight - drawHeight) / 2;
                    offsetX = canvasWidth * 0.05;
                } else {
                    drawHeight = canvasHeight * 0.9; // 여백 10%
                    drawWidth = drawHeight * imgRatio;
                    offsetX = (canvasWidth - drawWidth) / 2;
                    offsetY = canvasHeight * 0.05;
                }

                console.log('이미지 그리기 설정:', { drawWidth, drawHeight, offsetX, offsetY });

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // 흰색 배경
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                console.log('배경 그리기 완료');

                // 이미지 그리기
                ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);
                console.log('원본 이미지 그리기 완료');

                // 이미지 처리
                const imageData = ctx.getImageData(offsetX, offsetY, drawWidth, drawHeight);
                console.log('이미지 데이터 추출 완료:', imageData.width, 'x', imageData.height);
                
                let processedData;
                try {
                    processedData = applyImageProcessing(imageData, threshold, lineWidth);
                    console.log('이미지 처리 성공');
                } catch (processingError) {
                    console.error('이미지 처리 실패, 기본 처리 시도:', processingError);
                    // 처리 실패시 기본 처리를 직접 호출
                    processedData = applyBasicProcessing(imageData, threshold, lineWidth);
                    console.log('기본 처리로 완료');
                }
                
                // 처리된 데이터가 유효한지 확인
                if (processedData && processedData.data && processedData.width && processedData.height) {
                    ctx.putImageData(processedData, offsetX, offsetY);
                    console.log('처리된 이미지 적용 완료');
                } else {
                    console.error('처리된 데이터가 유효하지 않습니다:', processedData);
                    throw new Error('이미지 처리 결과가 유효하지 않습니다');
                }

                // 색칠 가이드 추가 (원본 이미지를 작게 표시)
                if (includeGuide) {
                    addColoringGuide(ctx, canvasWidth, canvasHeight, currentImage, paper.name, orientation);
                    console.log('색칠 가이드 추가 완료');
                }

                // 변환된 결과 표시
                const resultSection = document.getElementById('convertedImageResult');
                if (resultSection) {
                    resultSection.style.display = 'block';
                    console.log('결과 섹션 표시됨');
                    
                    // 결과 섹션으로 부드럽게 스크롤
                    setTimeout(() => {
                        resultSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                } else {
                    console.error('convertedImageResult 요소를 찾을 수 없습니다');
                }

                console.log('웹 이미지 처리 완료');
            } catch (error) {
                console.error('웹 이미지 처리 중 오류:', error);
                alert('이미지 처리 중 오류가 발생했습니다: ' + error.message);
            }
        }

        function processImageInWorkspace() {
            console.log('워크스페이스에서 이미지 처리 시작');
            
            // 기본 설정값
            const threshold = 128;
            const lineWidth = 1;
            const includeGuide = false;
            
            const canvas = document.getElementById('convertedCanvas');
            const ctx = canvas.getContext('2d');
            
            // 적당한 크기로 조정 (400x400 최대)
            const maxSize = 400;
            let canvasWidth, canvasHeight;
            
            if (currentImage.width > currentImage.height) {
                canvasWidth = Math.min(currentImage.width, maxSize);
                canvasHeight = (currentImage.height * canvasWidth) / currentImage.width;
            } else {
                canvasHeight = Math.min(currentImage.height, maxSize);
                canvasWidth = (currentImage.width * canvasHeight) / currentImage.height;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 흰색 배경
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 이미지 그리기
            ctx.drawImage(currentImage, 0, 0, canvasWidth, canvasHeight);
            
            // 이미지 처리
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const processedData = applyImageProcessing(imageData, threshold, lineWidth);
            
            ctx.putImageData(processedData, 0, 0);
            
            // 변환된 결과 표시
            document.getElementById('convertedImageResult').style.display = 'block';
            console.log('이미지 변환 완료');
        }

        // processImage 함수 제거됨 - 새로운 UI에서는 processUploadImage와 processWebImage 사용

        function applyImageProcessing(imageData, threshold, lineWidth) {
            console.log('이미지 처리 시작:', { 
                width: imageData.width, 
                height: imageData.height, 
                threshold, 
                lineWidth,
                openCvReady,
                cvAvailable: typeof cv !== 'undefined'
            });
            
            // OpenCV 사용 가능 여부에 관계없이 빠른 처리를 우선 제공
            const useOpenCV = isOpenCVSafe(imageData.width, imageData.height);
            
            if (useOpenCV) {
                console.log('OpenCV 처리 모드 사용');
                try {
                    return applyOpenCVProcessing(imageData, threshold, lineWidth);
                } catch (opencvError) {
                    console.warn('OpenCV 처리 중 오류 발생, 기본 처리로 폴백:', opencvError);
                    return applyBasicProcessing(imageData, threshold, lineWidth);
                }
            } else {
                console.log('기본 이미지 처리 사용');
                
                // OpenCV가 아직 로딩 중이면 백그라운드에서 계속 시도
                if (openCvLoadAttempts > 0 && openCvLoadAttempts < maxRetries) {
                    console.info('💡 OpenCV 로딩 중... 기본 처리를 먼저 제공합니다.');
                } else if (openCvLoadAttempts >= maxRetries) {
                    console.info('💡 OpenCV 로딩 실패로 기본 이미지 처리를 사용합니다.');
                } else {
                    console.info('💡 기본 이미지 처리를 사용합니다.');
                }
                
                try {
                    const result = applyBasicProcessing(imageData, threshold, lineWidth);
                    console.log('기본 처리 성공:', result ? '유효한 결과' : '무효한 결과');
                    return result;
                } catch (basicError) {
                    console.error('기본 처리도 실패:', basicError);
                    throw basicError;
                }
            }
        }

        function applyOpenCVProcessing(imageData, threshold, lineWidth) {
            try {
                console.log('OpenCV 처리 시작');
                
                // OpenCV가 안전하게 사용 가능한지 재확인
                if (!isOpenCVSafe(imageData.width, imageData.height)) {
                    throw new Error('OpenCV를 안전하게 사용할 수 없는 상태입니다');
                }
                
                const width = imageData.width;
                const height = imageData.height;
                
                // ImageData 유효성 검사
                if (!imageData || !imageData.data || width <= 0 || height <= 0) {
                    throw new Error('유효하지 않은 ImageData입니다');
                }
                
                if (imageData.data.length !== width * height * 4) {
                    throw new Error(`ImageData 크기 불일치: 예상 ${width * height * 4}, 실제 ${imageData.data.length}`);
                }
                
                console.log('ImageData 검증 완료:', { width, height, dataLength: imageData.data.length });
                
                // 메모리 정리 후 Mat 생성
                if (typeof window.gc === 'function') {
                    window.gc(); // 가능한 경우 가비지 컬렉션 강제 실행
                }
                
                // 안전한 Mat 생성 방법
                console.log('Mat 생성 중...');
                let src;
                
                try {
                    // 방법 1: Canvas를 통한 안전한 방법 (가장 안정적)
                    console.log('방법 1 시도: Canvas를 통한 안전한 생성');
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // Canvas에서 Mat 생성 (OpenCV.js의 안전한 방법)
                    src = cv.imread(tempCanvas);
                    console.log('방법 1 성공: Canvas를 통한 Mat 생성');
                    
                } catch (method1Error) {
                    console.warn('방법 1 실패:', method1Error);
                    
                    try {
                        // 방법 2: matFromImageData 사용 (더 안전한 접근)
                        console.log('방법 2 시도: matFromImageData 사용');
                        src = cv.matFromImageData(imageData);
                        console.log('방법 2 성공: matFromImageData');
                        
                    } catch (method2Error) {
                        console.warn('방법 2 실패:', method2Error);
                        
                        try {
                            // 방법 3: 작은 크기로 리사이즈 후 처리
                            console.log('방법 3 시도: 이미지 크기 축소');
                            const maxSize = 600; // 더 작은 크기로 제한
                            let newWidth = width;
                            let newHeight = height;
                            
                            if (width > maxSize || height > maxSize) {
                                const ratio = Math.min(maxSize / width, maxSize / height);
                                newWidth = Math.floor(width * ratio);
                                newHeight = Math.floor(height * ratio);
                                
                                console.log(`이미지 크기 축소: ${width}x${height} → ${newWidth}x${newHeight}`);
                                
                                // Canvas로 리사이즈
                                const resizeCanvas = document.createElement('canvas');
                                const resizeCtx = resizeCanvas.getContext('2d');
                                resizeCanvas.width = newWidth;
                                resizeCanvas.height = newHeight;
                                
                                const tempCanvas = document.createElement('canvas');
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCanvas.width = width;
                                tempCanvas.height = height;
                                tempCtx.putImageData(imageData, 0, 0);
                                
                                resizeCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
                                
                                // 리사이즈된 이미지에서 Mat 생성
                                src = cv.imread(resizeCanvas);
                                console.log(`방법 3 성공: 리사이즈 완료`);
                            } else {
                                // 크기가 적당하지만 여전히 실패하는 경우, 강제 리사이즈
                                const forceSize = 400;
                                const ratio = Math.min(forceSize / width, forceSize / height);
                                newWidth = Math.floor(width * ratio);
                                newHeight = Math.floor(height * ratio);
                                
                                console.log(`강제 리사이즈: ${width}x${height} → ${newWidth}x${newHeight}`);
                                
                                const resizeCanvas = document.createElement('canvas');
                                const resizeCtx = resizeCanvas.getContext('2d');
                                resizeCanvas.width = newWidth;
                                resizeCanvas.height = newHeight;
                                
                                const tempCanvas = document.createElement('canvas');
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCanvas.width = width;
                                tempCanvas.height = height;
                                tempCtx.putImageData(imageData, 0, 0);
                                
                                resizeCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
                                
                                src = cv.imread(resizeCanvas);
                                console.log('방법 3 성공: 강제 리사이즈 완료');
                            }
                        } catch (method3Error) {
                            console.error('모든 Mat 생성 방법 실패:', method3Error);
                            throw new Error('Mat 생성 불가능 - OpenCV 메모리 문제로 인해 이미지 처리를 할 수 없습니다');
                        }
                    }
                }
                
                if (!src || src.empty()) {
                    throw new Error('생성된 Mat이 비어있습니다');
                }
                
                console.log('Mat 생성 완료:', { rows: src.rows, cols: src.cols, type: src.type() });
                
                // 실제 처리 크기 저장 (리사이즈된 경우를 위해)
                const processWidth = src.cols;
                const processHeight = src.rows;
                const needsResize = (processWidth !== width || processHeight !== height);
                
                const gray = new cv.Mat();
                const blurred = new cv.Mat();
                const edges = new cv.Mat();
                const result = new cv.Mat();
                
                // 1. 그레이스케일 변환
                console.log('1. 그레이스케일 변환 중...');
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 2. 가우시안 블러 (노이즈 제거)
                console.log('2. 가우시안 블러 적용 중...');
                const kernelSize = 5;
                cv.GaussianBlur(gray, blurred, new cv.Size(kernelSize, kernelSize), 1.4, 1.4);
                
                // 3. Canny 엣지 검출
                const lowThreshold = Math.max(10, threshold * 0.4);
                const highThreshold = Math.min(255, threshold * 1.2);
                console.log('3. Canny 엣지 검출 중...', { lowThreshold, highThreshold });
                cv.Canny(blurred, edges, lowThreshold, highThreshold);
                
                // 4. 형태학적 연산 (선 정리)
                console.log('4. 형태학적 연산 적용 중...', { lineWidth });
                if (lineWidth > 1) {
                    const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(lineWidth, lineWidth));
                    cv.dilate(edges, result, kernel);
                    kernel.delete();
                } else {
                    edges.copyTo(result);
                }
                
                // 5. 색상 반전 (검은 배경에 흰 선 → 흰 배경에 검은 선)
                console.log('5. 색상 반전 중...');
                cv.bitwise_not(result, result);
                
                // 6. 컬러 이미지로 변환
                console.log('6. 컬러 변환 중...');
                const colorResult = new cv.Mat();
                cv.cvtColor(result, colorResult, cv.COLOR_GRAY2RGBA);
                
                // 7. 원본 크기로 복원 (필요한 경우)
                let finalResult = colorResult;
                if (needsResize) {
                    console.log(`7. 원본 크기로 복원 중: ${processWidth}x${processHeight} → ${width}x${height}`);
                    finalResult = new cv.Mat();
                    const dsize = new cv.Size(width, height);
                    cv.resize(colorResult, finalResult, dsize, 0, 0, cv.INTER_LINEAR);
                    colorResult.delete(); // 임시 결과 삭제
                }
                
                // Mat을 ImageData로 안전하게 변환
                console.log('8. ImageData로 변환 중...');
                let outputImageData;
                try {
                    // Mat 데이터 크기 검증
                    const expectedSize = width * height * 4; // RGBA
                    if (finalResult.data.length !== expectedSize) {
                        throw new Error(`Mat 데이터 크기 불일치: 예상 ${expectedSize}, 실제 ${finalResult.data.length}`);
                    }
                    
                    // 안전한 데이터 복사
                    const outputData = new Uint8ClampedArray(finalResult.data);
                    outputImageData = new ImageData(outputData, width, height);
                    
                    console.log('ImageData 변환 완료:', { 
                        width: outputImageData.width, 
                        height: outputImageData.height, 
                        dataLength: outputImageData.data.length 
                    });
                } catch (conversionError) {
                    throw new Error('ImageData 변환 중 오류: ' + conversionError.message);
                }
                
                console.log('OpenCV 처리 완료!');
                
                // 안전한 메모리 정리
                console.log('9. 메모리 정리 중...');
                try {
                    if (src && !src.isDeleted()) src.delete();
                    if (gray && !gray.isDeleted()) gray.delete();
                    if (blurred && !blurred.isDeleted()) blurred.delete();
                    if (edges && !edges.isDeleted()) edges.delete();
                    if (result && !result.isDeleted()) result.delete();
                    if (finalResult && finalResult !== colorResult && !finalResult.isDeleted()) finalResult.delete();
                    // colorResult는 finalResult와 같거나 이미 삭제됨
                } catch (deleteError) {
                    console.warn('메모리 정리 중 경고:', deleteError);
                }
                
                return outputImageData;
                
            } catch (error) {
                console.error('OpenCV 처리 중 오류 발생:', error);
                
                // 오류 발생 시에도 메모리 정리 시도
                try {
                    if (typeof src !== 'undefined' && src && !src.isDeleted()) src.delete();
                    if (typeof gray !== 'undefined' && gray && !gray.isDeleted()) gray.delete();
                    if (typeof blurred !== 'undefined' && blurred && !blurred.isDeleted()) blurred.delete();
                    if (typeof edges !== 'undefined' && edges && !edges.isDeleted()) edges.delete();
                    if (typeof result !== 'undefined' && result && !result.isDeleted()) result.delete();
                    if (typeof colorResult !== 'undefined' && colorResult && !colorResult.isDeleted()) colorResult.delete();
                    if (typeof finalResult !== 'undefined' && finalResult && finalResult !== colorResult && !finalResult.isDeleted()) finalResult.delete();
                } catch (cleanupError) {
                    console.warn('오류 시 메모리 정리 실패:', cleanupError);
                }
                
                // 기본 처리로 폴백
                return applyBasicProcessing(imageData, threshold, lineWidth);
            }
        }

        function applyBasicProcessing(imageData, threshold, lineWidth) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;

            // 1. 그레이스케일 변환
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }

            // 2. 가우시안 블러 적용 (노이즈 제거)
            const blurred = applyGaussianBlur(data, width, height, 1.0);

            // 3. 개선된 엣지 검출 (Canny-like)
            const edges = applyCannyllikeEdgeDetection(blurred, width, height, threshold);

            // 4. 형태학적 연산 (선 정리)
            const cleaned = applyMorphologicalOperations(edges, width, height);

            // 5. 선 굵기 적용
            let final = cleaned;
            if (lineWidth > 1) {
                final = applyLineThickening(cleaned, width, height, lineWidth);
            }

            return new ImageData(final, width, height);
        }

        function applyGaussianBlur(data, width, height, sigma) {
            const blurred = new Uint8ClampedArray(data.length);
            const kernelSize = Math.ceil(sigma * 3) * 2 + 1;
            const kernel = [];
            const center = Math.floor(kernelSize / 2);
            
            // 가우시안 커널 생성
            let sum = 0;
            for (let i = 0; i < kernelSize; i++) {
                const x = i - center;
                const value = Math.exp(-(x * x) / (2 * sigma * sigma));
                kernel[i] = value;
                sum += value;
            }
            
            // 정규화
            for (let i = 0; i < kernelSize; i++) {
                kernel[i] /= sum;
            }

            // 수평 블러
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const px = Math.max(0, Math.min(width - 1, x + k - center));
                        const idx = (y * width + px) * 4;
                        value += data[idx] * kernel[k];
                    }
                    const idx = (y * width + x) * 4;
                    blurred[idx] = blurred[idx + 1] = blurred[idx + 2] = Math.round(value);
                    blurred[idx + 3] = 255;
                }
            }

            // 수직 블러
            const result = new Uint8ClampedArray(data.length);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const py = Math.max(0, Math.min(height - 1, y + k - center));
                        const idx = (py * width + x) * 4;
                        value += blurred[idx] * kernel[k];
                    }
                    const idx = (y * width + x) * 4;
                    result[idx] = result[idx + 1] = result[idx + 2] = Math.round(value);
                    result[idx + 3] = 255;
                }
            }

            return result;
        }

        function applyCannyllikeEdgeDetection(data, width, height, threshold) {
            const edges = new Uint8ClampedArray(data.length);
            
            // Sobel 연산자
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
            
            const gradients = [];
            const directions = [];

            // 그래디언트 계산
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            const intensity = data[idx];
                            gx += intensity * sobelX[dy + 1][dx + 1];
                            gy += intensity * sobelY[dy + 1][dx + 1];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const direction = Math.atan2(gy, gx);
                    
                    gradients[y * width + x] = magnitude;
                    directions[y * width + x] = direction;
                }
            }

            // Non-maximum suppression (간소화된 버전)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const magnitude = gradients[y * width + x] || 0;
                    
                    if (magnitude > threshold) {
                        // 인접 픽셀과 비교하여 극값인지 확인
                        const neighbors = [
                            gradients[(y-1) * width + (x-1)] || 0,
                            gradients[(y-1) * width + x] || 0,
                            gradients[(y-1) * width + (x+1)] || 0,
                            gradients[y * width + (x-1)] || 0,
                            gradients[y * width + (x+1)] || 0,
                            gradients[(y+1) * width + (x-1)] || 0,
                            gradients[(y+1) * width + x] || 0,
                            gradients[(y+1) * width + (x+1)] || 0
                        ];
                        
                        const isLocalMax = neighbors.every(n => magnitude >= n);
                        
                        if (isLocalMax) {
                            edges[idx] = edges[idx + 1] = edges[idx + 2] = 0; // 검은색 (엣지)
                        } else {
                            edges[idx] = edges[idx + 1] = edges[idx + 2] = 255; // 흰색
                        }
                    } else {
                        edges[idx] = edges[idx + 1] = edges[idx + 2] = 255; // 흰색
                    }
                    edges[idx + 3] = 255; // 알파
                }
            }

            return edges;
        }

        function applyMorphologicalOperations(data, width, height) {
            // 침식(erosion) 후 팽창(dilation)으로 노이즈 제거
            const eroded = applyErosion(data, width, height);
            const dilated = applyDilation(eroded, width, height);
            return dilated;
        }

        function applyErosion(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // 3x3 커널에서 모든 픽셀이 검은색인지 확인
                    let allBlack = true;
                    for (let dy = -1; dy <= 1 && allBlack; dy++) {
                        for (let dx = -1; dx <= 1 && allBlack; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            if (data[nIdx] > 128) allBlack = false;
                        }
                    }
                    
                    if (allBlack) {
                        result[idx] = result[idx + 1] = result[idx + 2] = 0;
                    } else {
                        result[idx] = result[idx + 1] = result[idx + 2] = 255;
                    }
                    result[idx + 3] = 255;
                }
            }
            return result;
        }

        function applyDilation(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // 3x3 커널에서 하나라도 검은색이면 검은색으로
                    let hasBlack = false;
                    for (let dy = -1; dy <= 1 && !hasBlack; dy++) {
                        for (let dx = -1; dx <= 1 && !hasBlack; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            if (data[nIdx] < 128) hasBlack = true;
                        }
                    }
                    
                    if (hasBlack) {
                        result[idx] = result[idx + 1] = result[idx + 2] = 0;
                    } else {
                        result[idx] = result[idx + 1] = result[idx + 2] = 255;
                    }
                    result[idx + 3] = 255;
                }
            }
            return result;
        }

        function applyLineThickening(data, width, height, lineWidth) {
            const result = new Uint8ClampedArray(data.length);
            
            // 흰색으로 초기화
            for (let i = 0; i < result.length; i += 4) {
                result[i] = result[i + 1] = result[i + 2] = 255;
                result[i + 3] = 255;
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    if (data[idx] < 128) { // 검은색 픽셀이면
                        // 원형 브러시로 굵게 만들기
                        for (let dy = -lineWidth; dy <= lineWidth; dy++) {
                            for (let dx = -lineWidth; dx <= lineWidth; dx++) {
                                const newX = x + dx;
                                const newY = y + dy;
                                
                                if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance <= lineWidth) {
                                        const newIdx = (newY * width + newX) * 4;
                                        result[newIdx] = result[newIdx + 1] = result[newIdx + 2] = 0;
                                        result[newIdx + 3] = 255;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        function addColoringGuide(ctx, width, height, originalImage, paperName, orientation) {
            // 색칠 가이드 크기 설정 (전체 크기의 1/4 정도)
            const guideSize = Math.min(width, height) * 0.25;
            const guideWidth = guideSize;
            const guideHeight = guideSize * (originalImage.height / originalImage.width);
            
            // 우측 상단에 위치
            const guideX = width - guideWidth - 20;
            const guideY = 20;
            
            // 가이드 배경 (흰색)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(guideX - 5, guideY - 5, guideWidth + 10, guideHeight + 35);
            
            // 가이드 테두리
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(guideX - 5, guideY - 5, guideWidth + 10, guideHeight + 35);
            
            // 원본 이미지 그리기 (색칠 가이드)
            ctx.drawImage(originalImage, guideX, guideY, guideWidth, guideHeight);
            
            // 이미지 테두리
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(guideX, guideY, guideWidth, guideHeight);
            
            // 가이드 레이블
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('색칠 가이드', guideX + guideWidth / 2, guideY + guideHeight + 20);
            
            // 종이 정보 (좌측 하단)
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            const infoText = `${paperName} | ${orientation === 'portrait' ? '세로' : '가로'} | ${new Date().toLocaleDateString('ko-KR')}`;
            ctx.fillText(infoText, 20, height - 10);
            
            // 네 모서리에 자르기 가이드
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            const markSize = 10;
            const margin = 5;
            
            [[margin, margin], [width - margin, margin], [margin, height - margin], [width - margin, height - margin]].forEach(([x, y]) => {
                ctx.beginPath();
                ctx.moveTo(x - markSize, y);
                ctx.lineTo(x + markSize, y);
                ctx.moveTo(x, y - markSize);
                ctx.lineTo(x, y + markSize);
                ctx.stroke();
            });
            
            // 텍스트 정렬 초기화
            ctx.textAlign = 'left';
        }

        // showResult, downloadResult, resetApp 함수 제거됨 - 새로운 UI에서는 사용하지 않음

        console.log('앱 로드 완료');
    </script>
</body>
</html>