<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì»¬ëŸ¬ë§ë¶ ë©”ì´ì»¤ - AI ì´ë¯¸ì§€ ìƒì„± í¬í•¨</title>
    <link rel="stylesheet" href="./styles/main.css">
    <script>
        // OpenCV.js ì•ˆì •ì  ë¡œë”© ì‹œìŠ¤í…œ
        let openCvLoadAttempts = 0;
        const maxRetries = 3;
        let openCvLoadTimeout;
        
        function loadOpenCV() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                
                // ìºì‹œ ë²„ìŠ¤íŒ…ì„ ìœ„í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
                const cacheBuster = Date.now();
                script.src = `https://docs.opencv.org/4.8.0/opencv.js?v=${cacheBuster}`;
                
                // 10ì´ˆ íƒ€ì„ì•„ì›ƒ ì„¤ì •
                const timeoutId = setTimeout(() => {
                    script.remove();
                    reject(new Error('OpenCV.js ë¡œë”© íƒ€ì„ì•„ì›ƒ'));
                }, 10000);
                
                script.onload = () => {
                    clearTimeout(timeoutId);
                    // cvê°€ ì‹¤ì œë¡œ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        resolve();
                    } else {
                        reject(new Error('OpenCV.js ë¡œë“œ ë˜ì—ˆì§€ë§Œ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ'));
                    }
                };
                
                script.onerror = () => {
                    clearTimeout(timeoutId);
                    script.remove();
                    reject(new Error('OpenCV.js ë¡œë“œ ì‹¤íŒ¨'));
                };
                
                document.head.appendChild(script);
            });
        }
        
        async function initOpenCV() {
            openCvLoadAttempts++;
            
            try {
                updateOpenCVStatus('loading', `OpenCV.js ë¡œë”© ì¤‘... (${openCvLoadAttempts}/${maxRetries})`);
                
                await loadOpenCV();
                
                // ì¶”ê°€ ì´ˆê¸°í™” ëŒ€ê¸° (OpenCVê°€ ì™„ì „íˆ ì¤€ë¹„ë  ë•Œê¹Œì§€)
                await new Promise(resolve => {
                    const checkReady = () => {
                        if (typeof cv !== 'undefined' && cv.Mat) {
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    checkReady();
                });
                
                onOpenCvReady();
                
            } catch (error) {
                console.error(`OpenCV ë¡œë”© ì‹œë„ ${openCvLoadAttempts} ì‹¤íŒ¨:`, error);
                
                if (openCvLoadAttempts < maxRetries) {
                    updateOpenCVStatus('retry', `ì¬ì‹œë„ ì¤‘... (${openCvLoadAttempts + 1}/${maxRetries})`);
                    setTimeout(() => initOpenCV(), 2000); // 2ì´ˆ í›„ ì¬ì‹œë„
                } else {
                    updateOpenCVStatus('failed', 'OpenCV.js ë¡œë“œ ì‹¤íŒ¨ - ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©');
                    console.warn('OpenCV.js ë¡œë“œ ì‹¤íŒ¨. ê¸°ë³¸ ì´ë¯¸ì§€ ì²˜ë¦¬ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                }
            }
        }
        
        function updateOpenCVStatus(status, message) {
            const statusElements = document.querySelectorAll('.opencv-status');
            statusElements.forEach(el => {
                el.textContent = message;
                el.className = 'opencv-status';
                
                switch(status) {
                    case 'loading':
                        el.style.color = '#ff9800';
                        el.textContent = 'â³ ' + message;
                        break;
                    case 'retry':
                        el.style.color = '#2196F3';
                        el.textContent = 'ğŸ”„ ' + message;
                        break;
                    case 'failed':
                        el.style.color = '#f44336';
                        el.textContent = 'âš ï¸ ' + message;
                        el.innerHTML += '<br><button onclick="retryOpenCV()" style="font-size:0.8em; margin-top:5px; padding:2px 8px; background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer;">ë‹¤ì‹œ ì‹œë„</button>';
                        break;
                    case 'success':
                        el.style.color = 'green';
                        el.textContent = 'âœ… ' + message;
                        break;
                }
            });
        }
        
        function retryOpenCV() {
            openCvLoadAttempts = 0;
            initOpenCV();
        }
        
        // í˜ì´ì§€ ë¡œë“œ í›„ OpenCV ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            initOpenCV();
        });
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ì»¬ëŸ¬ë§ë¶ ë©”ì´ì»¤</h1>
            <p>ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì›¹ì—ì„œ ìˆ˜ì§‘í•˜ê±°ë‚˜ AIë¡œ ìµœì í™”í•˜ì—¬ ì»¬ëŸ¬ë§ë¶ìœ¼ë¡œ ë³€í™˜í•´ë³´ì„¸ìš”!</p>
        </div>

        <!-- ëª¨ë“œ ì„ íƒ íƒ­ -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="upload" data-short="ğŸ“ ì—…ë¡œë“œ">
                ğŸ“ íŒŒì¼ ì—…ë¡œë“œ
            </button>
            <button class="mode-tab" data-mode="web" data-short="ğŸŒ ì›¹ìˆ˜ì§‘">
                ğŸŒ ì›¹ ì´ë¯¸ì§€ ìˆ˜ì§‘
            </button>
            <button class="mode-tab" data-mode="ai" data-short="ğŸ¤– AIìƒì„±">
                ğŸ¤– AI ì´ë¯¸ì§€ ìƒì„±
            </button>
        </div>

        <!-- íŒŒì¼ ì—…ë¡œë“œ ëª¨ë“œ -->
        <div id="upload-mode" class="mode-content active">
            <div class="upload-section">
                <div class="upload-box" id="uploadBox">
                    <div class="upload-icon">ğŸ“</div>
                    <h3>ì´ë¯¸ì§€ íŒŒì¼ ì—…ë¡œë“œ</h3>
                    <p>í´ë¦­í•˜ê±°ë‚˜ íŒŒì¼ì„ ë“œë˜ê·¸í•´ì„œ ì—…ë¡œë“œí•˜ì„¸ìš”</p>
                    <p style="font-size: 0.9em; color: #888;">ì—¬ëŸ¬ íŒŒì¼ ì„ íƒ ê°€ëŠ¥ â€¢ ì¶”ê°€ ì—…ë¡œë“œ ì‹œ ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€</p>
                    <p class="file-info">ì§€ì› í˜•ì‹: JPG, PNG, GIF, WEBP</p>
                    <input type="file" id="fileInput" accept="image/*" multiple hidden>
                </div>
                
                <!-- ì—…ë¡œë“œëœ íŒŒì¼ ì‘ì—… ê³µê°„ (ê°¤ëŸ¬ë¦¬ + ë¯¸ë¦¬ë³´ê¸°) -->
                <div id="uploadWorkspace" class="web-workspace" style="display: none;">
                    <div class="workspace-container">
                        <!-- ì™¼ìª½: ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ (1/3) -->
                        <div class="gallery-panel">
                            <div class="gallery-header">
                                <h3>ğŸ“ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë“¤</h3>
                                <p id="uploadImageCount" style="color: #888; font-size: 0.9em; margin-bottom: 8px;">ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì—†ìŒ</p>
                                <p style="color: #666; margin: 0; font-size: 0.9em;">ì›í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                            </div>
                            <div class="gallery-scrollable">
                                <div id="uploadImageGrid" class="image-grid-compact"></div>
                            </div>
                        </div>

                        <!-- ì˜¤ë¥¸ìª½: ì„ íƒëœ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ë° ë³€í™˜ (2/3) -->
                        <div class="preview-panel">
                            <!-- ì„ íƒëœ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° -->
                            <div id="uploadSelectedImagePreview" class="selected-preview" style="display: none;">
                                <h3>ğŸ“· ì„ íƒëœ ì´ë¯¸ì§€</h3>
                                <div class="image-display">
                                    <img id="uploadSelectedImage" alt="ì„ íƒëœ ì´ë¯¸ì§€">
                                </div>
                            </div>

                            <!-- ì—…ë¡œë“œ ì´ë¯¸ì§€ ì„¤ì • ì˜µì…˜ -->
                            <div id="uploadControlsSection" class="web-controls-section" style="display: none;">
                                <h3>âš™ï¸ ë³€í™˜ ì„¤ì •</h3>
                                <div class="controls-grid-compact">
                                    <div class="control-group">
                                        <div class="opencv-status" style="font-size: 0.8em; color: orange; margin-bottom: 5px;">OpenCV.js ë¡œë”© ì¤‘...</div>
                                        <label for="uploadThreshold">ìœ¤ê³½ì„  ë¯¼ê°ë„:</label>
                                        <div class="slider-group">
                                            <input type="range" id="uploadThreshold" min="50" max="200" value="90">
                                            <span id="uploadThresholdValue">90</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadLineWidth">ì„  êµµê¸°:</label>
                                        <div class="slider-group">
                                            <input type="range" id="uploadLineWidth" min="1" max="5" value="1">
                                            <span id="uploadLineWidthValue">1</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadPaperSize">ğŸ“„ ì¢…ì´ ì‚¬ì´ì¦ˆ:</label>
                                        <select id="uploadPaperSize">
                                            <option value="a4">A4 (210Ã—297mm)</option>
                                            <option value="a5">A5 (148Ã—210mm)</option>
                                            <option value="b4">B4 (250Ã—353mm)</option>
                                            <option value="b5">B5 (176Ã—250mm)</option>
                                            <option value="5x7">5Ã—7 ì¸í™”ìš© (5Ã—7")</option>
                                            <option value="4x6">4Ã—6 ì¸í™”ìš© (4Ã—6")</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="uploadOrientation">ğŸ”„ ë°©í–¥:</label>
                                        <select id="uploadOrientation">
                                            <option value="portrait">ì„¸ë¡œ (Portrait)</option>
                                            <option value="landscape">ê°€ë¡œ (Landscape)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="uploadIncludeGuide" checked>
                                            <label for="uploadIncludeGuide">ğŸŒˆ ìƒ‰ì¹  ê°€ì´ë“œ í¬í•¨</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="web-action-buttons">
                                    <button id="uploadProcessBtn" class="primary-btn">ğŸ¨ ì»¬ëŸ¬ë§ë¶ ë³€í™˜</button>
                                </div>
                            </div>
                            
                            <div id="uploadConvertedImageResult" class="converted-result" style="display: none;">
                                <h3>ğŸ¨ ë³€í™˜ëœ ì»¬ëŸ¬ë§ë¶</h3>
                                <div class="image-display">
                                    <canvas id="uploadConvertedCanvas"></canvas>
                                </div>
                                <div class="result-actions">
                                    <button id="uploadDownloadBtn" class="primary-btn">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì›¹ ì´ë¯¸ì§€ ìˆ˜ì§‘ ëª¨ë“œ -->
        <div id="web-mode" class="mode-content">
            <div class="web-section">
                <div class="input-group">
                    <input type="url" id="imageUrl" placeholder="ì´ë¯¸ì§€ URLì„ ì…ë ¥í•˜ì„¸ìš”...">
                    <button id="loadImageBtn" class="primary-btn">ì´ë¯¸ì§€ ë¡œë“œ</button>
                </div>
                <div class="url-info">
                    <p>ğŸ’¡ <strong>ì‚¬ìš© íŒ:</strong></p>
                    <ul>
                        <li>ì§ì ‘ ì´ë¯¸ì§€ ë§í¬ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (jpg, png, gif, webp)</li>
                        <li>ì´ë¯¸ì§€ ë¡œë“œì— ì‹¤íŒ¨í•˜ë©´ <strong>íŒŒì¼ ì—…ë¡œë“œ ëª¨ë“œ</strong>ë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.</li>
                    </ul>
                    
                    <div style="margin-top: 20px;">
                        <p style="font-weight: bold; margin-bottom: 10px;">ğŸ”— ì˜ˆì‹œ ì´ë¯¸ì§€ URL:</p>
                        <div class="example-urls">
                            <span class="example-url" onclick="setExampleUrl('https://pokemonkorea.co.kr/pokedex')">Pokemon Korea</span>
                            <span class="example-url" onclick="setExampleUrl('https://namu.wiki/w/Hello%20Kitty')">ë‚˜ë¬´ìœ„í‚¤ í—¬ë¡œí‚¤í‹°</span>
                        </div>
                        
                        <p style="font-size: 0.9em; color: #888; margin-top: 10px;">
                            âš ï¸ ì¼ë¶€ ì‚¬ì´íŠ¸ëŠ” CORS ì •ì±…ìœ¼ë¡œ ì¸í•´ ë¡œë“œë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                        </p>
                    </div>
                </div>

                <!-- ì›¹ ì´ë¯¸ì§€ ì‘ì—… ê³µê°„ (ê°¤ëŸ¬ë¦¬ + ë¯¸ë¦¬ë³´ê¸°) -->
                <div id="webWorkspace" class="web-workspace" style="display: none;">
                    <div class="workspace-container">
                        <!-- ì™¼ìª½: ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ (1/3) -->
                        <div class="gallery-panel">
                            <div class="gallery-header">
                                <h3>ğŸ–¼ï¸ ë°œê²¬ëœ ì´ë¯¸ì§€ë“¤</h3>
                                <p id="imageCount" style="color: #888; font-size: 0.9em; margin-bottom: 8px;">ë¡œë”© ì¤‘...</p>
                                <p style="color: #666; margin: 0; font-size: 0.9em;">ì›í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                            </div>
                            <div class="gallery-scrollable">
                                <div id="imageGrid" class="image-grid-compact"></div>
                                <div id="galleryLoading" class="gallery-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <p>ì´ë¯¸ì§€ë¥¼ ê²€ìƒ‰í•˜ëŠ” ì¤‘...</p>
                                </div>
                            </div>
                        </div>

                        <!-- ì˜¤ë¥¸ìª½: ì„ íƒëœ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ë° ë³€í™˜ (2/3) -->
                        <div class="preview-panel">
                            <!-- ë¡œë”© ìƒíƒœ í‘œì‹œ -->
                            <div id="imageLoadingStatus" class="loading-status" style="display: none;">
                                <div class="loading-content">
                                    <div class="spinner-small"></div>
                                    <h3>ğŸ”„ ì´ë¯¸ì§€ ë¡œë”© ì¤‘...</h3>
                                    <p>ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</p>
                                </div>
                            </div>

                            <div id="selectedImagePreview" class="selected-preview" style="display: none;">
                                <h3>ğŸ“· ì„ íƒëœ ì´ë¯¸ì§€</h3>
                                <div class="image-display">
                                    <img id="selectedImage" alt="ì„ íƒëœ ì´ë¯¸ì§€">
                                </div>
                            </div>

                            <!-- ì›¹ ì´ë¯¸ì§€ ì„¤ì • ì˜µì…˜ -->
                            <div id="webControlsSection" class="web-controls-section" style="display: none;">
                                <h3>âš™ï¸ ë³€í™˜ ì„¤ì •</h3>
                                <div class="controls-grid-compact">
                                    <div class="control-group">
                                        <div class="opencv-status" style="font-size: 0.8em; color: orange; margin-bottom: 5px;">OpenCV.js ë¡œë”© ì¤‘...</div>
                                        <label for="webThreshold">ìœ¤ê³½ì„  ë¯¼ê°ë„:</label>
                                        <div class="slider-group">
                                            <input type="range" id="webThreshold" min="50" max="200" value="90">
                                            <span id="webThresholdValue">90</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webLineWidth">ì„  êµµê¸°:</label>
                                        <div class="slider-group">
                                            <input type="range" id="webLineWidth" min="1" max="5" value="1">
                                            <span id="webLineWidthValue">1</span>
                                        </div>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webPaperSize">ğŸ“„ ì¢…ì´ ì‚¬ì´ì¦ˆ:</label>
                                        <select id="webPaperSize">
                                            <option value="a4">A4 (210Ã—297mm)</option>
                                            <option value="a5">A5 (148Ã—210mm)</option>
                                            <option value="b4">B4 (250Ã—353mm)</option>
                                            <option value="b5">B5 (176Ã—250mm)</option>
                                            <option value="5x7">5Ã—7 ì¸í™”ìš© (5Ã—7")</option>
                                            <option value="4x6">4Ã—6 ì¸í™”ìš© (4Ã—6")</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <label for="webOrientation">ğŸ”„ ë°©í–¥:</label>
                                        <select id="webOrientation">
                                            <option value="portrait">ì„¸ë¡œ (Portrait)</option>
                                            <option value="landscape">ê°€ë¡œ (Landscape)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="control-group">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="webIncludeGuide" checked>
                                            <label for="webIncludeGuide">ğŸŒˆ ìƒ‰ì¹  ê°€ì´ë“œ í¬í•¨</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="web-action-buttons">
                                    <button id="webProcessBtn" class="primary-btn">ğŸ¨ ì»¬ëŸ¬ë§ë¶ ë³€í™˜</button>
                                </div>
                            </div>
                            
                            <div id="convertedImageResult" class="converted-result" style="display: none;">
                                <h3>ğŸ¨ ë³€í™˜ëœ ì»¬ëŸ¬ë§ë¶</h3>
                                <div class="image-display">
                                    <canvas id="convertedCanvas"></canvas>
                                </div>
                                <div class="result-actions">
                                    <button id="downloadBtn" class="primary-btn">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI ì´ë¯¸ì§€ ìƒì„± ëª¨ë“œ -->
        <div id="ai-mode" class="mode-content">
            <div class="ai-section">
                <div class="prompt-section">
                    <h3>ğŸ¤– AI ì´ë¯¸ì§€ ìƒì„±</h3>
                    <div class="features-info">
                        <p><strong>ğŸ¤– AI ê°•í™” ê¸°ëŠ¥:</strong></p>
                        <ul>
                            <li><strong>ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŠ¸ ê°œì„ :</strong> ë‹¨ì–´ ëª‡ ê°œë§Œ ì…ë ¥í•´ë„ ìë™ìœ¼ë¡œ ìµœì í™”ëœ í”„ë¡¬í”„íŠ¸ë¡œ ë³€í™˜</li>
                            <li><strong>ì»¬ëŸ¬ë§ë¶ íŠ¹í™”:</strong> ì»¬ëŸ¬ë§ë¶ì— ì í•©í•œ ì„ ëª…í•œ ìœ¤ê³½ì„ ê³¼ ë‹¨ìˆœí•œ êµ¬ì¡°ë¡œ ìƒì„±</li>
                            <li><strong>ë‹¤ì–‘í•œ ìŠ¤íƒ€ì¼:</strong> ë™ë¬¼, ì‹ë¬¼, ê±´ë¬¼, ìºë¦­í„° ë“± ë‹¤ì–‘í•œ ì£¼ì œ ì§€ì›</li>
                        </ul>
                    </div>
                    
                    <div class="input-group">
                        <textarea id="promptInput" placeholder="ì–´ë–¤ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê³  ì‹¶ë‚˜ìš”? (ì˜ˆ: ê·€ì—¬ìš´ ê³ ì–‘ì´, ì„±, ê½ƒ)" rows="3"></textarea>
                        <div class="prompt-controls">
                            <button id="improvePromptBtn" class="secondary-btn">í”„ë¡¬í”„íŠ¸ ê°œì„ </button>
                            <button id="generateBtn" class="primary-btn">ì´ë¯¸ì§€ ìƒì„±</button>
                        </div>
                    </div>
                    
                    <div class="example-prompts">
                        <p><strong>ì˜ˆì‹œ í”„ë¡¬í”„íŠ¸:</strong></p>
                        <div class="prompt-examples">
                            <span class="example-prompt" data-prompt="ê·€ì—¬ìš´ ê°•ì•„ì§€">ê·€ì—¬ìš´ ê°•ì•„ì§€</span>
                            <span class="example-prompt" data-prompt="ë§ˆë²•ì˜ ì„±">ë§ˆë²•ì˜ ì„±</span>
                            <span class="example-prompt" data-prompt="ì˜ˆìœ ê½ƒ">ì˜ˆìœ ê½ƒ</span>
                            <span class="example-prompt" data-prompt="ìš°ì£¼ ë¡œì¼“">ìš°ì£¼ ë¡œì¼“</span>
                        </div>
                    </div>
                </div>

                <!-- AI ì´ë¯¸ì§€ ê²°ê³¼ -->
                <div id="aiResults" class="ai-results" style="display: none;">
                    <h3>ìƒì„±ëœ ì´ë¯¸ì§€</h3>
                    <div class="generated-images" id="generatedImages"></div>
                </div>
            </div>
        </div>


        <!-- ë¡œë”© í‘œì‹œ -->
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
            <div class="loading-spinner">
                <div class="spinner"></div>
                <p id="loadingText">ì²˜ë¦¬ ì¤‘...</p>
            </div>
        </div>
    </div>

    <script>
        // ì¢…ì´ ì‚¬ì´ì¦ˆ ì •ì˜ (72DPI ê¸°ì¤€)
        const paperSizes = {
            a4: { width: 595, height: 842, name: 'A4' },
            a5: { width: 420, height: 595, name: 'A5' },
            b4: { width: 708, height: 1001, name: 'B4' },
            b5: { width: 499, height: 708, name: 'B5' },
            '5x7': { width: 360, height: 504, name: '5Ã—7' },
            '4x6': { width: 288, height: 432, name: '4Ã—6' }
        };

        let currentImage = null;
        let openCvReady = false;

        // OpenCV.js ì´ˆê¸°í™” ì™„ë£Œ
        function onOpenCvReady() {
            openCvReady = true;
            console.log('OpenCV.jsê°€ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            try {
                const buildInfo = cv.getBuildInformation();
                console.log('OpenCV ë²„ì „ ì •ë³´:', buildInfo);
                updateOpenCVStatus('success', 'OpenCV.js ë¡œë“œ ì™„ë£Œ');
            } catch (error) {
                console.warn('OpenCV ë²„ì „ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', error);
                updateOpenCVStatus('success', 'OpenCV.js ë¡œë“œë¨');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            initApp();
        });

        function initApp() {
            setupEventListeners();
            setupSliders();
            updateTabText(); // ì´ˆê¸° íƒ­ í…ìŠ¤íŠ¸ ì„¤ì •
            console.log('ì•± ì´ˆê¸°í™” ì™„ë£Œ');
        }

        // í™”ë©´ í¬ê¸°ì— ë”°ë¥¸ íƒ­ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        function updateTabText() {
            const tabs = document.querySelectorAll('.mode-tab');
            const isMobile = window.innerWidth <= 480;
            
            tabs.forEach(tab => {
                const originalText = tab.textContent.trim();
                const shortText = tab.dataset.short;
                
                if (isMobile && shortText) {
                    tab.textContent = shortText;
                } else {
                    // ì›ë˜ í…ìŠ¤íŠ¸ ë³µì› (data-shortê°€ ì—†ëŠ” ê²½ìš°ë¥¼ ìœ„í•œ ì²˜ë¦¬)
                    if (!tab.dataset.original) {
                        tab.dataset.original = originalText;
                    }
                    tab.textContent = tab.dataset.original;
                }
            });
        }

        function setupEventListeners() {
            // ëª¨ë“œ íƒ­ ì „í™˜
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    switchMode(this.dataset.mode);
                });
            });

            // íŒŒì¼ ì—…ë¡œë“œ
            document.getElementById('uploadBox').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            document.getElementById('fileInput').addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 0) handleMultipleFiles(files);
            });

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì§€ì›
            const uploadBox = document.getElementById('uploadBox');
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.classList.add('dragover');
            });

            uploadBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadBox.classList.remove('dragover');
            });

            uploadBox.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadBox.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                if (files.length > 0) handleMultipleFiles(files);
            });

            // ì›¹ ì´ë¯¸ì§€ ë¡œë“œ
            document.getElementById('loadImageBtn').addEventListener('click', loadWebImage);
            
            // Enter í‚¤ë¡œ ì›¹ ì´ë¯¸ì§€ ë¡œë“œ
            document.getElementById('imageUrl').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    loadWebImage();
                }
            });

            // ê¸°ì¡´ ë²„íŠ¼ ì´ë²¤íŠ¸ ì œê±° (ìƒˆë¡œìš´ ì—…ë¡œë“œ UIì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
            
            // ì›¹ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸
            const webProcessBtn = document.getElementById('webProcessBtn');
            if (webProcessBtn) {
                webProcessBtn.addEventListener('click', processWebImage);
            }

            // ì—…ë¡œë“œ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸
            const uploadProcessBtn = document.getElementById('uploadProcessBtn');
            if (uploadProcessBtn) {
                uploadProcessBtn.addEventListener('click', processUploadImage);
            }

            const uploadDownloadBtn = document.getElementById('uploadDownloadBtn');
            if (uploadDownloadBtn) {
                uploadDownloadBtn.addEventListener('click', downloadUploadResult);
            }

            // ì›¹ ëª¨ë“œ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸
            const webDownloadBtn = document.getElementById('downloadBtn');
            if (webDownloadBtn) {
                webDownloadBtn.addEventListener('click', downloadWebResult);
            }

            // ì°½ í¬ê¸° ë³€ê²½ ì‹œ íƒ­ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            window.addEventListener('resize', updateTabText);
        }

        function switchMode(mode) {
            // íƒ­ í™œì„±í™”
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

            // ì»¨í…ì¸  ì „í™˜
            document.querySelectorAll('.mode-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${mode}-mode`).classList.add('active');

            // ëª¨ë“  UI ìƒíƒœ ì´ˆê¸°í™”
            resetAllUIStates();

            console.log(`ëª¨ë“œ ì „í™˜: ${mode}`);
        }

        function resetAllUIStates() {
            // í˜„ì¬ ì´ë¯¸ì§€ ì´ˆê¸°í™”
            currentImage = null;
            
            // ëª¨ë“  ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            const sectionsToHide = [
                'webWorkspace',
                'selectedImagePreview',
                'webControlsSection',
                'convertedImageResult',
                'imageLoadingStatus',
                'aiResults',
                'uploadWorkspace',
                'uploadSelectedImagePreview',
                'uploadControlsSection',
                'uploadConvertedImageResult'
            ];
            
            sectionsToHide.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'none';
                }
            });

            // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.value = '';
            }
            
            const imageUrl = document.getElementById('imageUrl');
            if (imageUrl) {
                imageUrl.value = '';
            }
            
            const promptInput = document.getElementById('promptInput');
            if (promptInput) {
                promptInput.value = '';
            }

            // ì›¹ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ ì´ˆê¸°í™”
            const imageGrid = document.getElementById('imageGrid');
            if (imageGrid) {
                imageGrid.innerHTML = '';
            }

            // ìƒì„±ëœ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ ì´ˆê¸°í™”
            const generatedImages = document.getElementById('generatedImages');
            if (generatedImages) {
                generatedImages.innerHTML = '';
            }

            // ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ ì´ˆê¸°í™”
            const uploadImageGrid = document.getElementById('uploadImageGrid');
            if (uploadImageGrid) {
                uploadImageGrid.innerHTML = '';
            }

            // ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ë°°ì—´ ì´ˆê¸°í™”
            uploadedImages = [];

            // ì—…ë¡œë“œ ì´ë¯¸ì§€ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            const uploadImageCount = document.getElementById('uploadImageCount');
            if (uploadImageCount) {
                uploadImageCount.textContent = 'ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì—†ìŒ';
            }

            console.log('ëª¨ë“  UI ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ');
        }

        function setExampleUrl(url) {
            document.getElementById('imageUrl').value = url;
            console.log('ì˜ˆì‹œ URL ì„¤ì •:', url);
        }

        function loadWebImage() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) {
                alert('URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            console.log('ì›¹ í˜ì´ì§€ ë¡œë“œ ì‹œì‘:', url);

            // URLì´ ì´ë¯¸ì§€ íŒŒì¼ì¸ì§€ í™•ì¸
            if (isImageUrl(url)) {
                loadDirectImage(url);
            } else {
                scrapeWebPage(url);
            }
        }

        function isImageUrl(url) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
            const lowercaseUrl = url.toLowerCase();
            return imageExtensions.some(ext => 
                lowercaseUrl.includes(ext) && 
                (lowercaseUrl.endsWith(ext) || lowercaseUrl.includes(ext + '?'))
            );
        }

        function loadDirectImage(url) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                currentImage = img;
                showPreview(img);
                showControls();
                console.log('ì§ì ‘ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ');
            };
            
            img.onerror = function() {
                alert('ì´ë¯¸ì§€ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. URLì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                console.error('ì§ì ‘ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', url);
            };
            
            img.src = url;
        }

        async function scrapeWebPage(url) {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');

            // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ í‘œì‹œ ë° ë¡œë”© í‘œì‹œ
            showWebWorkspace();
            if (galleryLoading) {
                galleryLoading.style.display = 'block';
            }
            imageGrid.innerHTML = '';

            // íŠ¹ì • ì‚¬ì´íŠ¸ì˜ ê²½ìš° ì§ì ‘ ì´ë¯¸ì§€ URL ì œê³µ
            if (url.includes('pokemonkorea.co.kr')) {
                showPokemonImages();
                return;
            }

            try {
                // ê¸°ì¡´ ì‚¬ì´íŠ¸ì™€ ë™ì¼í•œ ë°©ì‹ ì‚¬ìš©
                const proxyUrl = 'https://api.allorigins.win/get?url=';
                console.log('ì›¹í˜ì´ì§€ ë¡œë“œ ì‹œì‘:', proxyUrl + url);
                const response = await fetch(proxyUrl + encodeURIComponent(url));
                
                if (!response.ok) {
                    throw new Error('ì›¹ì‚¬ì´íŠ¸ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                const data = await response.json();
                const htmlContent = data.contents;
                
                // HTML íŒŒì‹±í•˜ì—¬ ì´ë¯¸ì§€ ì°¾ê¸° (ê¸°ì¡´ ì‚¬ì´íŠ¸ ë°©ì‹)
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                const imgElements = doc.querySelectorAll('img');
                
                const images = [];
                const baseUrlObj = new URL(url);
                const baseUrl = baseUrlObj.origin;
                
                for (let img of imgElements) {
                    let src = img.src || 
                             img.getAttribute('data-src') || 
                             img.getAttribute('data-lazy') || 
                             img.getAttribute('data-srcset') ||
                             img.getAttribute('data-original') ||
                             img.getAttribute('data-img') ||
                             img.getAttribute('data-load-src') ||
                             img.getAttribute('data-url');
                    
                    if (src) {
                        // data-srcset ì²˜ë¦¬ (ì²« ë²ˆì§¸ URLë§Œ ì‚¬ìš©)
                        if (src.includes(' ')) {
                            src = src.split(' ')[0];
                        }
                        
                        // ìƒëŒ€ ê²½ë¡œë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
                        if (src.startsWith('//')) {
                            src = 'https:' + src;
                        } else if (src.startsWith('/')) {
                            src = baseUrl + src;
                        } else if (!src.startsWith('http')) {
                            src = baseUrl + '/' + src;
                        }
                        
                        // ì´ë¯¸ì§€ íŒŒì¼ì¸ì§€ í™•ì¸í•˜ê³  ì¤‘ë³µ ì œê±° (50ê°œ ì œí•œ)
                        if (isValidImageSrc(src) && !images.some(item => item.url === src) && images.length < 50) {
                            images.push({
                                url: src,
                                alt: img.alt || img.title || `ì´ë¯¸ì§€ ${images.length + 1}`
                            });
                        }
                    }
                }
                
                if (galleryLoading) {
                    if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }
                }

                // CSS background-imageë„ ì²´í¬
                const allElements = doc.querySelectorAll('*');
                for (let element of allElements) {
                    const computedStyle = element.style;
                    const backgroundImage = computedStyle.backgroundImage || element.getAttribute('style');
                    
                    if (backgroundImage && backgroundImage.includes('url(')) {
                        const urlMatch = backgroundImage.match(/url\(['"]?([^'"()]+)['"]?\)/);
                        if (urlMatch && urlMatch[1] && images.length < 50) {
                            let bgSrc = urlMatch[1];
                            
                            // ìƒëŒ€ ê²½ë¡œë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
                            if (bgSrc.startsWith('//')) {
                                bgSrc = 'https:' + bgSrc;
                            } else if (bgSrc.startsWith('/')) {
                                bgSrc = baseUrl + bgSrc;
                            } else if (!bgSrc.startsWith('http')) {
                                bgSrc = baseUrl + '/' + bgSrc;
                            }
                            
                            if (isValidImageSrc(bgSrc) && !images.some(item => item.url === bgSrc)) {
                                images.push({
                                    url: bgSrc,
                                    alt: `Background Image ${images.length + 1}`
                                });
                            }
                        }
                    }
                }

                if (images.length === 0) {
                    imageGrid.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }

                // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ í‘œì‹œ ë° ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ ë¡œë“œ
                showWebWorkspace();
                displayImageGallery(images); // 50ê°œë¡œ ì œí•œë¨
                console.log(`${images.length}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.`);

            } catch (error) {
                if (galleryLoading) {
                    if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }
                }
                imageGrid.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 20px;">
                        <h4>âŒ í˜ì´ì§€ ë¡œë“œ ì‹¤íŒ¨</h4>
                        <p>ì›¹ì‚¬ì´íŠ¸ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error.message}</p>
                        <br>
                        <p><strong>ëŒ€ì•ˆ:</strong></p>
                        <button onclick="showSampleImages()" class="primary-btn" style="margin-top: 10px;">
                            ğŸ“· ìƒ˜í”Œ ì´ë¯¸ì§€ ë³´ê¸°
                        </button>
                    </div>
                `;
                console.error('ì›¹ ìŠ¤í¬ë˜í•‘ ì‹¤íŒ¨:', error);
            }
        }

        function isValidImageSrc(src) {
            if (!src || src.length < 10) return false;
            
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const lowercaseSrc = src.toLowerCase();
            
            // ì´ë¯¸ì§€ í™•ì¥ì í™•ì¸
            const hasImageExt = imageExtensions.some(ext => 
                lowercaseSrc.includes(ext) && 
                (lowercaseSrc.endsWith(ext) || lowercaseSrc.includes(ext + '?'))
            );
            
            // ì‘ì€ ì•„ì´ì½˜ì´ë‚˜ ë¡œê³  ì œì™¸
            const isSmallIcon = lowercaseSrc.includes('icon') || 
                               lowercaseSrc.includes('logo') || 
                               lowercaseSrc.includes('favicon') ||
                               lowercaseSrc.includes('thumb') ||
                               src.includes('1x1') ||
                               src.includes('16x16') ||
                               src.includes('32x32');
            
            return hasImageExt && !isSmallIcon;
        }

        function showPokemonImages() {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');
            
            if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }

            // í¬ì¼“ëª¬ 1~151 (1ì„¸ëŒ€ ì „ì²´) ë° ì¸ê¸° í¬ì¼“ëª¬ë“¤
            const pokemonData = [
                // 1ì„¸ëŒ€ ìŠ¤íƒ€í„° ì§„í™”ë¼ì¸
                { num: '001', name: 'ì´ìƒí•´ì”¨' }, { num: '002', name: 'ì´ìƒí•´í’€' }, { num: '003', name: 'ì´ìƒí•´ê½ƒ' },
                { num: '004', name: 'íŒŒì´ë¦¬' }, { num: '005', name: 'ë¦¬ìë“œ' }, { num: '006', name: 'ë¦¬ìëª½' },
                { num: '007', name: 'ê¼¬ë¶€ê¸°' }, { num: '008', name: 'ì–´ë‹ˆë¶€ê¸°' }, { num: '009', name: 'ê±°ë¶ì™•' },
                
                // ì¸ê¸° í¬ì¼“ëª¬ë“¤
                { num: '025', name: 'í”¼ì¹´ì¸„' }, { num: '026', name: 'ë¼ì´ì¸„' },
                { num: '039', name: 'í‘¸ë¦°' }, { num: '040', name: 'í‘¸í¬ë¦°' },
                { num: '052', name: 'ë‚˜ì˜¹ì´' }, { num: '053', name: 'í˜ë¥´ì‹œì˜¨' },
                { num: '054', name: 'ê³ ë¼íŒŒë•' }, { num: '055', name: 'ê³¨ë•' },
                { num: '104', name: 'í……êµ¬ë¦¬' }, { num: '105', name: 'í……êµ¬ë¦¬' },
                { num: '131', name: 'ë¼í”„ë¼ìŠ¤' }, { num: '143', name: 'ì ë§Œë³´' },
                
                // ì „ì„¤ì˜ í¬ì¼“ëª¬
                { num: '144', name: 'í”„ë¦¬ì ¸' }, { num: '145', name: 'ì¬ë”' }, { num: '146', name: 'íŒŒì´ì–´' },
                { num: '150', name: 'ë®¤ì¸ ' }, { num: '151', name: 'ë®¤' },
                
                // ê¸°íƒ€ ì¸ê¸° í¬ì¼“ëª¬ë“¤
                { num: '016', name: 'êµ¬êµ¬' }, { num: '017', name: 'í”¼ì£¤' }, { num: '018', name: 'í”¼ì£¤íˆ¬' },
                { num: '019', name: 'ê¼¬ë ›' }, { num: '020', name: 'ë ˆíŠ¸ë¼' },
                { num: '035', name: 'í”½ì‹œ' }, { num: '036', name: 'í”½ì‹œ' },
                { num: '037', name: 'ì‹ìŠ¤í…Œì¼' }, { num: '038', name: 'ë‚˜ì¸í…Œì¼' },
                { num: '058', name: 'ê°€ë””' }, { num: '059', name: 'ìœˆë””' },
                { num: '063', name: 'ìºì´ì‹œ' }, { num: '064', name: 'ìœ¤ê²”ë¼' }, { num: '065', name: 'í›„ë”˜' },
                { num: '066', name: 'ì•Œí†µëª¬' }, { num: '067', name: 'ê·¼ìœ¡ëª¬' }, { num: '068', name: 'ê´´ë ¥ëª¬' },
                { num: '074', name: 'ê¼¬ë§ˆëŒ' }, { num: '075', name: 'ë°êµ¬ë¦¬' }, { num: '076', name: 'ë”±êµ¬ë¦¬' },
                { num: '077', name: 'í¬ë‹ˆíƒ€' }, { num: '078', name: 'ë‚ ìŒ©ë§ˆ' },
                { num: '083', name: 'íŒŒì˜¤ë¦¬' }, { num: '084', name: 'ë‘ë‘' }, { num: '085', name: 'ë‘íŠ¸ë¦¬ì˜¤' },
                { num: '090', name: 'ì…€ëŸ¬' }, { num: '091', name: 'íŒŒë¥´ì…€' },
                { num: '092', name: 'ê³ ì˜¤ìŠ¤' }, { num: '093', name: 'ê³ ìš°ìŠ¤íŠ¸' }, { num: '094', name: 'íŒ¬í…€' },
                { num: '095', name: 'ë¡±ìŠ¤í†¤' }, { num: '096', name: 'ìŠ¬ë¦¬í”„' }, { num: '097', name: 'ìŠ¬ë¦¬í¼' },
                { num: '098', name: 'í¬ë©' }, { num: '099', name: 'í‚¹í¬ë©' },
                { num: '100', name: 'ì°Œë¦¬ë¦¬ê³µ' }, { num: '101', name: 'ë¶ë³¼' },
                { num: '102', name: 'ì•„ë¼ë¦¬' }, { num: '103', name: 'ë‚˜ì‹œ' },
                { num: '106', name: 'ì‹œë¼ì†Œëª¬' }, { num: '107', name: 'í™ìˆ˜ëª¬' },
                { num: '108', name: 'ë‚´ë£¸ë²¨íŠ¸' }, { num: '109', name: 'ë˜ê°€ìŠ¤' }, { num: '110', name: 'ë˜ë„ê°€ìŠ¤' },
                { num: '111', name: 'ë¿”ì¹´ë…¸' }, { num: '112', name: 'ì½”ë¿Œë¦¬' },
                { num: '113', name: 'ëŸ­í‚¤' }, { num: '114', name: 'ë©ì¿ ë¦¬' },
                { num: '115', name: 'ìº¥ì¹´' }, { num: '116', name: 'ì˜ë“œë¼' }, { num: '117', name: 'ì‹œë“œë¼' },
                { num: '118', name: 'ì½˜ì¹˜' }, { num: '119', name: 'ì™•ì½˜ì¹˜' },
                { num: '120', name: 'ë³„ê°€ì‚¬ë¦¬' }, { num: '121', name: 'ì•„ì¿ ìŠ¤íƒ€' },
                { num: '122', name: 'ë§ˆì„ë§¨' }, { num: '123', name: 'ìŠ¤ë¼í¬' },
                { num: '124', name: 'ë£¨ì£¼ë¼' }, { num: '125', name: 'ì—ë ˆí‚¤ë“œ' }, { num: '126', name: 'ë§ˆê·¸ë§ˆ' },
                { num: '127', name: 'ì˜ì‚¬ì´ì €' }, { num: '128', name: 'ì¼„íƒ€ë¡œìŠ¤' },
                { num: '129', name: 'ì‰ì–´í‚¹' }, { num: '130', name: 'ê°¸ë¼ë„ìŠ¤' },
                { num: '132', name: 'ë©”íƒ€ëª½' }, { num: '133', name: 'ì´ë¸Œì´' },
                { num: '134', name: 'ìƒ¤ë¯¸ë“œ' }, { num: '135', name: 'ì¥¬í”¼ì¬ë”' }, { num: '136', name: 'ë¶€ìŠ¤í„°' },
                { num: '137', name: 'í´ë¦¬ê³¤' }, { num: '138', name: 'ì•”ë‚˜ì´íŠ¸' }, { num: '139', name: 'ì•”ìŠ¤íƒ€' },
                { num: '140', name: 'íˆ¬êµ¬' }, { num: '141', name: 'íˆ¬êµ¬í‘¸ìŠ¤' },
                { num: '142', name: 'í”„í…Œë¼' }, { num: '147', name: 'ë¯¸ë‡¨' }, { num: '148', name: 'ì‹ ë‡¨' }, { num: '149', name: 'ë§ë‚˜ë‡½' }
            ];

            const images = pokemonData.slice(0, 50).map(pokemon => ({
                url: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${parseInt(pokemon.num)}.png`,
                alt: pokemon.name
            }));

            displayImageGallery(images);
            console.log(`${images.length}ê°œì˜ í¬ì¼“ëª¬ ì´ë¯¸ì§€ í‘œì‹œ`);
        }

        function showSampleImages() {
            const galleryLoading = document.getElementById('galleryLoading');
            const imageGrid = document.getElementById('imageGrid');
            
            if (galleryLoading) {
                galleryLoading.style.display = 'none';
            }

            // ë‹¤ì–‘í•œ ìƒ˜í”Œ ì´ë¯¸ì§€ë“¤
            const sampleImages = [
                { url: 'https://picsum.photos/300/400?random=1', alt: 'í’ê²½ 1' },
                { url: 'https://picsum.photos/400/300?random=2', alt: 'í’ê²½ 2' },
                { url: 'https://picsum.photos/350/350?random=3', alt: 'ìì—° 1' },
                { url: 'https://picsum.photos/300/500?random=4', alt: 'ìì—° 2' },
                { url: 'https://picsum.photos/400/400?random=5', alt: 'ë„ì‹œ 1' },
                { url: 'https://picsum.photos/350/450?random=6', alt: 'ë„ì‹œ 2' },
                { url: 'https://picsum.photos/320/380?random=7', alt: 'ì¶”ìƒ 1' },
                { url: 'https://picsum.photos/380/320?random=8', alt: 'ì¶”ìƒ 2' }
            ];

            showWebWorkspace();
            displayImageGallery(sampleImages);
            console.log('ìƒ˜í”Œ ì´ë¯¸ì§€ í‘œì‹œ');
        }

        function showWebWorkspace() {
            const webWorkspace = document.getElementById('webWorkspace');
            if (webWorkspace) {
                webWorkspace.style.display = 'block';
            } else {
                console.error('webWorkspace ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        function extractImagesFromHtml(html, baseUrl) {
            // ê°„ë‹¨í•œ ì •ê·œì‹ìœ¼ë¡œ ì´ë¯¸ì§€ URL ì¶”ì¶œ
            const imgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
            const images = [];
            let match;

            while ((match = imgRegex.exec(html)) !== null) {
                let imgUrl = match[1];
                
                // ìƒëŒ€ URLì„ ì ˆëŒ€ URLë¡œ ë³€í™˜
                if (imgUrl.startsWith('//')) {
                    imgUrl = 'https:' + imgUrl;
                } else if (imgUrl.startsWith('/')) {
                    const baseUrlObj = new URL(baseUrl);
                    imgUrl = baseUrlObj.origin + imgUrl;
                } else if (!imgUrl.startsWith('http')) {
                    const baseUrlObj = new URL(baseUrl);
                    imgUrl = new URL(imgUrl, baseUrlObj.href).href;
                }

                // ì´ë¯¸ì§€ íŒŒì¼ì¸ì§€ í™•ì¸í•˜ê³  ì¤‘ë³µ ì œê±°
                if (isImageUrl(imgUrl) && !images.some(img => img.url === imgUrl)) {
                    images.push({
                        url: imgUrl,
                        alt: match[0].match(/alt=["']([^"']*)["']/)?.[1] || 'Image'
                    });
                }
            }

            return images.slice(0, 20); // ìµœëŒ€ 20ê°œë§Œ í‘œì‹œ
        }

        function displayImageGallery(images) {
            const imageGrid = document.getElementById('imageGrid');
            if (!imageGrid) {
                console.error('imageGrid ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            imageGrid.innerHTML = '';

            // ìµœëŒ€ 50ê°œë¡œ ì œí•œ
            const limitedImages = images.slice(0, 50);
            console.log(`í‘œì‹œí•  ì´ë¯¸ì§€ ìˆ˜: ${limitedImages.length}ê°œ (ì›ë³¸: ${images.length}ê°œ)`);

            // ì´ë¯¸ì§€ ê°œìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸
            const imageCount = document.getElementById('imageCount');
            if (imageCount) {
                if (images.length > 50) {
                    imageCount.textContent = `${limitedImages.length}ê°œ í‘œì‹œ (ì´ ${images.length}ê°œ ì¤‘)`;
                } else {
                    imageCount.textContent = `ì´ ${limitedImages.length}ê°œ ì´ë¯¸ì§€`;
                }
            }

            limitedImages.forEach((imageInfo, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'gallery-image';
                
                const img = document.createElement('img');
                img.src = imageInfo.url;
                img.alt = imageInfo.alt;
                img.loading = 'lazy';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'image-info';
                infoDiv.textContent = `${index + 1}`;

                img.onload = function() {
                    console.log(`ì´ë¯¸ì§€ ${index + 1} ë¡œë“œ ì™„ë£Œ`);
                };

                img.onerror = function() {
                    imageDiv.style.display = 'none';
                };

                imageDiv.addEventListener('click', () => {
                    selectGalleryImage(imageInfo.url);
                });

                imageDiv.appendChild(img);
                imageDiv.appendChild(infoDiv);
                imageGrid.appendChild(imageDiv);
            });
        }

        async function selectGalleryImage(imageUrl) {
            console.log('ê°¤ëŸ¬ë¦¬ ì´ë¯¸ì§€ ì„ íƒ:', imageUrl);
            
            // ë¡œë”© ìƒíƒœ í‘œì‹œ
            showImageLoadingStatus();
            hideImagePreview();
            hideConvertedResult();
            
            // ë‹¤ì–‘í•œ í”„ë¡ì‹œ ì„œë¹„ìŠ¤ë“¤ ì‹œë„
            const proxyServices = [
                'https://cors-anywhere.herokuapp.com/',
                'https://api.allorigins.win/raw?url=',
                'https://thingproxy.freeboard.io/fetch/',
                'https://cors.eu.org/',
                'https://api.codetabs.com/v1/proxy?quest='
            ];
            
            let proxyIndex = 0;
            
            function tryNextProxy() {
                if (proxyIndex < proxyServices.length) {
                    const proxyUrl = proxyServices[proxyIndex];
                    const proxiedImageUrl = proxyUrl + encodeURIComponent(imageUrl);
                    
                    console.log(`í”„ë¡ì‹œ ${proxyIndex + 1} ì‹œë„:`, proxyUrl);
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    // íƒ€ì„ì•„ì›ƒ ì„¤ì • (10ì´ˆ)
                    const timeout = setTimeout(() => {
                        console.log(`í”„ë¡ì‹œ ${proxyIndex + 1} íƒ€ì„ì•„ì›ƒ`);
                        proxyIndex++;
                        tryNextProxy();
                    }, 10000);
                    
                    img.onload = function() {
                        clearTimeout(timeout);
                        console.log('ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ (í”„ë¡ì‹œ)');
                        currentImage = img;
                        hideImageLoadingStatus();
                        showSelectedImage(img);
                        showControls();
                    };
                    
                    img.onerror = function() {
                        clearTimeout(timeout);
                        console.log(`í”„ë¡ì‹œ ${proxyIndex + 1} ì‹¤íŒ¨, ë‹¤ìŒ ì‹œë„`);
                        proxyIndex++;
                        tryNextProxy();
                    };
                    
                    img.src = proxiedImageUrl;
                } else {
                    // ëª¨ë“  í”„ë¡ì‹œ ì‹¤íŒ¨ ì‹œ ì§ì ‘ ë¡œë“œ ì‹œë„
                    console.log('ëª¨ë“  í”„ë¡ì‹œ ì‹¤íŒ¨, ì§ì ‘ ë¡œë“œ ì‹œë„');
                    tryDirectImageLoad(imageUrl);
                }
            }
            
            tryNextProxy();
        }

        function tryDirectImageLoad(imageUrl) {
            console.log('ì§ì ‘ ì´ë¯¸ì§€ ë¡œë“œ ì‹œë„:', imageUrl);
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            // íƒ€ì„ì•„ì›ƒ ì„¤ì • (5ì´ˆ)
            const timeout = setTimeout(() => {
                console.log('ì§ì ‘ ë¡œë“œ íƒ€ì„ì•„ì›ƒ, ëŒ€ì²´ ì´ë¯¸ì§€ ìƒì„±');
                createFallbackImage(imageUrl);
            }, 5000);
            
            img.onload = function() {
                clearTimeout(timeout);
                console.log('ì§ì ‘ ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ');
                currentImage = img;
                hideImageLoadingStatus();
                showSelectedImage(img);
                showControls();
            };
            
            img.onerror = function() {
                clearTimeout(timeout);
                console.log('ì§ì ‘ ë¡œë“œë„ ì‹¤íŒ¨, ëŒ€ì²´ ì´ë¯¸ì§€ ìƒì„±');
                createFallbackImage(imageUrl);
            };
            
            img.src = imageUrl;
        }

        function createFallbackImage(originalUrl) {
            // ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ì´ë¯¸ì§€ ìƒì„±
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 400;
            canvas.height = 400;
            
            // ë°°ê²½ìƒ‰
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 400, 400);
            
            // í…Œë‘ë¦¬
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 398, 398);
            
            // í…ìŠ¤íŠ¸
            ctx.fillStyle = '#666';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì´ë¯¸ì§€ í”Œë ˆì´ìŠ¤í™€ë”', 200, 180);
            ctx.fillText('ì»¬ëŸ¬ë§ë¶ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥', 200, 210);
            
            // URL ì •ë³´
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            const shortUrl = originalUrl.length > 50 ? originalUrl.substring(0, 50) + '...' : originalUrl;
            ctx.fillText(shortUrl, 200, 240);
            
            // Canvasë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const img = new Image();
                
                img.onload = function() {
                    console.log('ëŒ€ì²´ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ');
                    currentImage = img;
                    hideImageLoadingStatus();
                    showSelectedImage(img);
                    showControls();
                    alert('ì›ë³¸ ì´ë¯¸ì§€ ë¡œë“œì— ì‹¤íŒ¨í•˜ì—¬ ëŒ€ì²´ ì´ë¯¸ì§€ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.\nì»¬ëŸ¬ë§ë¶ ë³€í™˜ì€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.');
                };
                
                img.src = url;
            });
        }

        function setupSliders() {
            // ê¸°ì¡´ ìŠ¬ë¼ì´ë” ì œê±°ë¨ - ìƒˆë¡œìš´ ì—…ë¡œë“œ UIì—ì„œëŠ” ê° ëª¨ë“œë³„ ìŠ¬ë¼ì´ë” ì‚¬ìš©

            // ì›¹ ìŠ¬ë¼ì´ë”
            const webThreshold = document.getElementById('webThreshold');
            const webThresholdValue = document.getElementById('webThresholdValue');
            const webLineWidth = document.getElementById('webLineWidth');
            const webLineWidthValue = document.getElementById('webLineWidthValue');
            
            if (webThreshold && webThresholdValue) {
                webThreshold.addEventListener('input', function() {
                    webThresholdValue.textContent = this.value;
                });
            }
            
            if (webLineWidth && webLineWidthValue) {
                webLineWidth.addEventListener('input', function() {
                    webLineWidthValue.textContent = this.value;
                });
            }

            // ì—…ë¡œë“œ ìŠ¬ë¼ì´ë”
            const uploadThreshold = document.getElementById('uploadThreshold');
            const uploadThresholdValue = document.getElementById('uploadThresholdValue');
            const uploadLineWidth = document.getElementById('uploadLineWidth');
            const uploadLineWidthValue = document.getElementById('uploadLineWidthValue');
            
            if (uploadThreshold && uploadThresholdValue) {
                uploadThreshold.addEventListener('input', function() {
                    uploadThresholdValue.textContent = this.value;
                });
            }
            
            if (uploadLineWidth && uploadLineWidthValue) {
                uploadLineWidth.addEventListener('input', function() {
                    uploadLineWidthValue.textContent = this.value;
                });
            }
        }

        let uploadedImages = []; // ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë“¤ì„ ì €ì¥í•  ë°°ì—´

        function handleMultipleFiles(files) {
            console.log(`${files.length}ê°œ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘`);
            let validFiles = [];

            // íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬
            for (let file of files) {
                if (!file.type.startsWith('image/')) {
                    alert(`${file.name}ì€(ëŠ”) ì´ë¯¸ì§€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.`);
                    continue;
                }

                if (file.size > 10 * 1024 * 1024) {
                    alert(`${file.name}ì˜ íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. 10MB ì´í•˜ì˜ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                    continue;
                }

                validFiles.push(file);
            }

            if (validFiles.length === 0) {
                return;
            }

            // ê¸°ì¡´ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë“¤ì„ ìœ ì§€í•˜ë©´ì„œ ìƒˆ ì´ë¯¸ì§€ ì¶”ê°€
            const uploadImageGrid = document.getElementById('uploadImageGrid');

            let loadedCount = 0;
            const totalCount = validFiles.length;

            // ê° íŒŒì¼ì„ ì½ì–´ì„œ ì´ë¯¸ì§€ë¡œ ë³€í™˜
            validFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // ì¤‘ë³µ íŒŒì¼ëª… ì²´í¬ (ê°™ì€ ì´ë¦„ì˜ íŒŒì¼ì´ ì´ë¯¸ ìˆìœ¼ë©´ ì¶”ê°€ ì•ˆí•¨)
                        const existingFile = uploadedImages.find(item => item.name === file.name);
                        if (!existingFile) {
                            uploadedImages.push({
                                image: img,
                                name: file.name,
                                size: file.size,
                                dataUrl: e.target.result
                            });
                        } else {
                            console.log(`íŒŒì¼ ${file.name}ì€ ì´ë¯¸ ì—…ë¡œë“œë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
                        }

                        loadedCount++;
                        if (loadedCount === totalCount) {
                            displayUploadedImages();
                            showUploadWorkspace();
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function displayUploadedImages() {
            const uploadImageGrid = document.getElementById('uploadImageGrid');
            const uploadImageCount = document.getElementById('uploadImageCount');
            
            uploadImageGrid.innerHTML = '';
            uploadImageCount.textContent = `ì´ ${uploadedImages.length}ê°œ ì´ë¯¸ì§€`;

            uploadedImages.forEach((imageInfo, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'gallery-image';
                
                const img = document.createElement('img');
                img.src = imageInfo.dataUrl;
                img.alt = imageInfo.name;
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'image-info';
                infoDiv.textContent = `${index + 1}`;

                imageDiv.addEventListener('click', () => {
                    selectUploadedImage(imageInfo);
                });

                imageDiv.appendChild(img);
                imageDiv.appendChild(infoDiv);
                uploadImageGrid.appendChild(imageDiv);
            });

            console.log(`${uploadedImages.length}ê°œ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ í‘œì‹œ ì™„ë£Œ`);
        }

        function showUploadWorkspace() {
            const uploadWorkspace = document.getElementById('uploadWorkspace');
            if (uploadWorkspace) {
                uploadWorkspace.style.display = 'block';
                console.log('ì—…ë¡œë“œ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ í‘œì‹œ');
            }
        }

        function selectUploadedImage(imageInfo) {
            console.log('ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ì„ íƒ:', imageInfo.name);
            currentImage = imageInfo.image;
            
            // ì„ íƒëœ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
            const uploadSelectedImagePreview = document.getElementById('uploadSelectedImagePreview');
            const uploadSelectedImage = document.getElementById('uploadSelectedImage');
            const uploadControlsSection = document.getElementById('uploadControlsSection');
            
            if (uploadSelectedImagePreview && uploadSelectedImage) {
                uploadSelectedImage.src = imageInfo.dataUrl;
                uploadSelectedImagePreview.style.display = 'block';
                console.log('ì„ íƒëœ ì—…ë¡œë“œ ì´ë¯¸ì§€ í‘œì‹œë¨');
            }

            // ì»¨íŠ¸ë¡¤ ì„¹ì…˜ í‘œì‹œ
            if (uploadControlsSection) {
                uploadControlsSection.style.display = 'block';
                console.log('ì—…ë¡œë“œ ì»¨íŠ¸ë¡¤ ì„¹ì…˜ í‘œì‹œë¨');
            }
        }

        function processUploadImage() {
            if (!currentImage) {
                alert('ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            console.log('ì—…ë¡œë“œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œì‘');

            try {
                // ì—…ë¡œë“œ ì»¨íŠ¸ë¡¤ì—ì„œ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
                const threshold = parseInt(document.getElementById('uploadThreshold').value);
                const lineWidth = parseInt(document.getElementById('uploadLineWidth').value);
                const paperSize = document.getElementById('uploadPaperSize').value;
                const orientation = document.getElementById('uploadOrientation').value;
                const includeGuide = document.getElementById('uploadIncludeGuide').checked;

                console.log('ì„¤ì •ê°’:', { threshold, lineWidth, paperSize, orientation, includeGuide });

                // ì¢…ì´ ì‚¬ì´ì¦ˆì— ë§ê²Œ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                const paper = paperSizes[paperSize];
                if (!paper) {
                    console.error('ì¢…ì´ ì‚¬ì´ì¦ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', paperSize);
                    return;
                }

                let canvasWidth, canvasHeight;
                
                if (orientation === 'landscape') {
                    canvasWidth = paper.height;
                    canvasHeight = paper.width;
                } else {
                    canvasWidth = paper.width;
                    canvasHeight = paper.height;
                }

                const canvas = document.getElementById('uploadConvertedCanvas');
                if (!canvas) {
                    console.error('uploadConvertedCanvas ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const ctx = canvas.getContext('2d');
                
                // ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ê²Œ í¬ê¸° ì¡°ì •
                const imgRatio = currentImage.width / currentImage.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgRatio > canvasRatio) {
                    drawWidth = canvasWidth * 0.9; // ì—¬ë°± 10%
                    drawHeight = drawWidth / imgRatio;
                    offsetY = (canvasHeight - drawHeight) / 2;
                    offsetX = canvasWidth * 0.05;
                } else {
                    drawHeight = canvasHeight * 0.9; // ì—¬ë°± 10%
                    drawWidth = drawHeight * imgRatio;
                    offsetX = (canvasWidth - drawWidth) / 2;
                    offsetY = canvasHeight * 0.05;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // í°ìƒ‰ ë°°ê²½
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);

                // ì´ë¯¸ì§€ ì²˜ë¦¬
                const imageData = ctx.getImageData(offsetX, offsetY, drawWidth, drawHeight);
                const processedData = applyImageProcessing(imageData, threshold, lineWidth);
                
                ctx.putImageData(processedData, offsetX, offsetY);

                // ìƒ‰ì¹  ê°€ì´ë“œ ì¶”ê°€
                if (includeGuide) {
                    addColoringGuide(ctx, canvasWidth, canvasHeight, currentImage, paper.name, orientation);
                }

                // ë³€í™˜ëœ ê²°ê³¼ í‘œì‹œ
                const resultSection = document.getElementById('uploadConvertedImageResult');
                if (resultSection) {
                    resultSection.style.display = 'block';
                    
                    // ê²°ê³¼ ì„¹ì…˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ìŠ¤í¬ë¡¤
                    setTimeout(() => {
                        resultSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                }

                console.log('ì—…ë¡œë“œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('ì—…ë¡œë“œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                alert('ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        function downloadUploadResult() {
            const canvas = document.getElementById('uploadConvertedCanvas');
            if (!canvas) {
                alert('ì²˜ë¦¬ëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const paperSize = document.getElementById('uploadPaperSize').value;
            const orientation = document.getElementById('uploadOrientation').value;
            const link = document.createElement('a');
            link.download = `coloring-book-upload-${paperSize}-${orientation}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            console.log('ì—…ë¡œë“œ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ');
        }

        function downloadWebResult() {
            const canvas = document.getElementById('convertedCanvas');
            if (!canvas) {
                alert('ì²˜ë¦¬ëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const paperSize = document.getElementById('webPaperSize').value;
            const orientation = document.getElementById('webOrientation').value;
            const link = document.createElement('a');
            link.download = `coloring-book-web-${paperSize}-${orientation}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            console.log('ì›¹ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ');
        }

        function handleFile(file) {
            // ê¸°ì¡´ ë‹¨ì¼ íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ëŠ” ì´ì œ handleMultipleFilesë¥¼ í˜¸ì¶œ
            handleMultipleFiles([file]);
        }

        // showPreview í•¨ìˆ˜ ì œê±°ë¨ - ìƒˆë¡œìš´ ê°¤ëŸ¬ë¦¬ UI ì‚¬ìš©

        function showImageLoadingStatus() {
            const loadingStatus = document.getElementById('imageLoadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'block';
                console.log('ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ í‘œì‹œ');
            }
        }

        function hideImageLoadingStatus() {
            const loadingStatus = document.getElementById('imageLoadingStatus');
            if (loadingStatus) {
                loadingStatus.style.display = 'none';
                console.log('ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ ìˆ¨ê¹€');
            }
        }

        function hideImagePreview() {
            const selectedImagePreview = document.getElementById('selectedImagePreview');
            if (selectedImagePreview) {
                selectedImagePreview.style.display = 'none';
            }
        }

        function hideConvertedResult() {
            const convertedResult = document.getElementById('convertedImageResult');
            const webControlsSection = document.getElementById('webControlsSection');
            
            if (convertedResult) {
                convertedResult.style.display = 'none';
            }
            if (webControlsSection) {
                webControlsSection.style.display = 'none';
            }
        }

        function showSelectedImage(img) {
            const selectedImagePreview = document.getElementById('selectedImagePreview');
            const selectedImage = document.getElementById('selectedImage');
            const webControlsSection = document.getElementById('webControlsSection');
            
            if (selectedImagePreview && selectedImage) {
                selectedImage.src = img.src;
                selectedImagePreview.style.display = 'block';
                console.log('ì„ íƒëœ ì´ë¯¸ì§€ í‘œì‹œë¨');
            } else {
                console.error('ì„ íƒëœ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }

            // ì›¹ ì»¨íŠ¸ë¡¤ ì„¹ì…˜ í‘œì‹œ
            if (webControlsSection) {
                webControlsSection.style.display = 'block';
                console.log('ì›¹ ì»¨íŠ¸ë¡¤ ì„¹ì…˜ í‘œì‹œë¨');
            }
        }

        function showControls() {
            // showControls í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            // íŒŒì¼ ì—…ë¡œë“œ ëª¨ë“œëŠ” ìƒˆë¡œìš´ ê°¤ëŸ¬ë¦¬ UIì—ì„œ ìì²´ì ìœ¼ë¡œ ì»¨íŠ¸ë¡¤ ì²˜ë¦¬
            // ì›¹ ì´ë¯¸ì§€ ëª¨ë“œëŠ” showSelectedImageì—ì„œ ì»¨íŠ¸ë¡¤ ì²˜ë¦¬
            console.log('showControls í˜¸ì¶œë¨ - ìƒˆë¡œìš´ UIì—ì„œëŠ” ê° ëª¨ë“œë³„ë¡œ ì»¨íŠ¸ë¡¤ ì²˜ë¦¬');
        }

        function processWebImage() {
            if (!currentImage) {
                alert('ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            console.log('ì›¹ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œì‘');

            try {
                // ì›¹ ì»¨íŠ¸ë¡¤ì—ì„œ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
                const threshold = parseInt(document.getElementById('webThreshold').value);
                const lineWidth = parseInt(document.getElementById('webLineWidth').value);
                const paperSize = document.getElementById('webPaperSize').value;
                const orientation = document.getElementById('webOrientation').value;
                const includeGuide = document.getElementById('webIncludeGuide').checked;

                console.log('ì„¤ì •ê°’:', { threshold, lineWidth, paperSize, orientation, includeGuide });

                // ì¢…ì´ ì‚¬ì´ì¦ˆì— ë§ê²Œ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                const paper = paperSizes[paperSize];
                if (!paper) {
                    console.error('ì¢…ì´ ì‚¬ì´ì¦ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', paperSize);
                    return;
                }

                let canvasWidth, canvasHeight;
                
                if (orientation === 'landscape') {
                    canvasWidth = paper.height;
                    canvasHeight = paper.width;
                } else {
                    canvasWidth = paper.width;
                    canvasHeight = paper.height;
                }

                console.log('ìº”ë²„ìŠ¤ í¬ê¸°:', { canvasWidth, canvasHeight });

                const canvas = document.getElementById('convertedCanvas');
                if (!canvas) {
                    console.error('convertedCanvas ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const ctx = canvas.getContext('2d');
                
                // ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ê²Œ í¬ê¸° ì¡°ì •
                const imgRatio = currentImage.width / currentImage.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgRatio > canvasRatio) {
                    drawWidth = canvasWidth * 0.9; // ì—¬ë°± 10%
                    drawHeight = drawWidth / imgRatio;
                    offsetY = (canvasHeight - drawHeight) / 2;
                    offsetX = canvasWidth * 0.05;
                } else {
                    drawHeight = canvasHeight * 0.9; // ì—¬ë°± 10%
                    drawWidth = drawHeight * imgRatio;
                    offsetX = (canvasWidth - drawWidth) / 2;
                    offsetY = canvasHeight * 0.05;
                }

                console.log('ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì„¤ì •:', { drawWidth, drawHeight, offsetX, offsetY });

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // í°ìƒ‰ ë°°ê²½
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                console.log('ë°°ê²½ ê·¸ë¦¬ê¸° ì™„ë£Œ');

                // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);
                console.log('ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì™„ë£Œ');

                // ì´ë¯¸ì§€ ì²˜ë¦¬
                const imageData = ctx.getImageData(offsetX, offsetY, drawWidth, drawHeight);
                console.log('ì´ë¯¸ì§€ ë°ì´í„° ì¶”ì¶œ ì™„ë£Œ:', imageData.width, 'x', imageData.height);
                
                const processedData = applyImageProcessing(imageData, threshold, lineWidth);
                console.log('ì´ë¯¸ì§€ ì²˜ë¦¬ ì™„ë£Œ');
                
                ctx.putImageData(processedData, offsetX, offsetY);
                console.log('ì²˜ë¦¬ëœ ì´ë¯¸ì§€ ì ìš© ì™„ë£Œ');

                // ìƒ‰ì¹  ê°€ì´ë“œ ì¶”ê°€ (ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‘ê²Œ í‘œì‹œ)
                if (includeGuide) {
                    addColoringGuide(ctx, canvasWidth, canvasHeight, currentImage, paper.name, orientation);
                    console.log('ìƒ‰ì¹  ê°€ì´ë“œ ì¶”ê°€ ì™„ë£Œ');
                }

                // ë³€í™˜ëœ ê²°ê³¼ í‘œì‹œ
                const resultSection = document.getElementById('convertedImageResult');
                if (resultSection) {
                    resultSection.style.display = 'block';
                    console.log('ê²°ê³¼ ì„¹ì…˜ í‘œì‹œë¨');
                    
                    // ê²°ê³¼ ì„¹ì…˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ìŠ¤í¬ë¡¤
                    setTimeout(() => {
                        resultSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                } else {
                    console.error('convertedImageResult ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }

                console.log('ì›¹ ì´ë¯¸ì§€ ì²˜ë¦¬ ì™„ë£Œ');
            } catch (error) {
                console.error('ì›¹ ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                alert('ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        function processImageInWorkspace() {
            console.log('ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì—ì„œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œì‘');
            
            // ê¸°ë³¸ ì„¤ì •ê°’
            const threshold = 128;
            const lineWidth = 1;
            const includeGuide = false;
            
            const canvas = document.getElementById('convertedCanvas');
            const ctx = canvas.getContext('2d');
            
            // ì ë‹¹í•œ í¬ê¸°ë¡œ ì¡°ì • (400x400 ìµœëŒ€)
            const maxSize = 400;
            let canvasWidth, canvasHeight;
            
            if (currentImage.width > currentImage.height) {
                canvasWidth = Math.min(currentImage.width, maxSize);
                canvasHeight = (currentImage.height * canvasWidth) / currentImage.width;
            } else {
                canvasHeight = Math.min(currentImage.height, maxSize);
                canvasWidth = (currentImage.width * canvasHeight) / currentImage.height;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // í°ìƒ‰ ë°°ê²½
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            ctx.drawImage(currentImage, 0, 0, canvasWidth, canvasHeight);
            
            // ì´ë¯¸ì§€ ì²˜ë¦¬
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const processedData = applyImageProcessing(imageData, threshold, lineWidth);
            
            ctx.putImageData(processedData, 0, 0);
            
            // ë³€í™˜ëœ ê²°ê³¼ í‘œì‹œ
            document.getElementById('convertedImageResult').style.display = 'block';
            console.log('ì´ë¯¸ì§€ ë³€í™˜ ì™„ë£Œ');
        }

        // processImage í•¨ìˆ˜ ì œê±°ë¨ - ìƒˆë¡œìš´ UIì—ì„œëŠ” processUploadImageì™€ processWebImage ì‚¬ìš©

        function applyImageProcessing(imageData, threshold, lineWidth) {
            console.log('ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œì‘:', { 
                width: imageData.width, 
                height: imageData.height, 
                threshold, 
                lineWidth,
                openCvReady,
                cvAvailable: typeof cv !== 'undefined'
            });
            
            if (openCvReady && typeof cv !== 'undefined') {
                console.log('OpenCV ì²˜ë¦¬ ëª¨ë“œ ì‚¬ìš©');
                return applyOpenCVProcessing(imageData, threshold, lineWidth);
            } else {
                // OpenCVê°€ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
                console.warn('OpenCVê°€ ë¡œë“œë˜ì§€ ì•Šì•„ ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                return applyBasicProcessing(imageData, threshold, lineWidth);
            }
        }

        function applyOpenCVProcessing(imageData, threshold, lineWidth) {
            try {
                console.log('OpenCV ì²˜ë¦¬ ì‹œì‘');
                
                // OpenCVê°€ ì •ë§ë¡œ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ ì¬í™•ì¸
                if (!openCvReady || typeof cv === 'undefined' || !cv.Mat) {
                    throw new Error('OpenCVê°€ ì™„ì „íˆ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                }
                
                const width = imageData.width;
                const height = imageData.height;
                
                // ImageData ìœ íš¨ì„± ê²€ì‚¬
                if (!imageData || !imageData.data || width <= 0 || height <= 0) {
                    throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ ImageDataì…ë‹ˆë‹¤');
                }
                
                if (imageData.data.length !== width * height * 4) {
                    throw new Error(`ImageData í¬ê¸° ë¶ˆì¼ì¹˜: ì˜ˆìƒ ${width * height * 4}, ì‹¤ì œ ${imageData.data.length}`);
                }
                
                console.log('ImageData ê²€ì¦ ì™„ë£Œ:', { width, height, dataLength: imageData.data.length });
                
                // ëŒ€ì•ˆì  ë°©ë²•ìœ¼ë¡œ Mat ìƒì„± ì‹œë„
                console.log('Mat ìƒì„± ì¤‘...');
                let src;
                try {
                    // ë°©ë²• 1: ì§ì ‘ Mat ìƒì„± í›„ ë°ì´í„° ë³µì‚¬
                    src = new cv.Mat(height, width, cv.CV_8UC4);
                    const dataHeap = new Uint8Array(cv.HEAP8.buffer, src.data, src.rows * src.cols * src.channels());
                    dataHeap.set(new Uint8Array(imageData.data));
                    console.log('ë°©ë²• 1 ì„±ê³µ: ì§ì ‘ Mat ìƒì„±');
                } catch (method1Error) {
                    console.warn('ë°©ë²• 1 ì‹¤íŒ¨:', method1Error);
                    
                    try {
                        // ë°©ë²• 2: Canvasë¥¼ í†µí•œ ìš°íšŒ ë°©ë²•
                        console.log('ë°©ë²• 2 ì‹œë„: Canvas ìš°íšŒ');
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        tempCtx.putImageData(imageData, 0, 0);
                        
                        // Canvasì—ì„œ Mat ì§ì ‘ ìƒì„±
                        src = cv.imread(tempCanvas);
                        console.log('ë°©ë²• 2 ì„±ê³µ: Canvas ìš°íšŒ');
                    } catch (method2Error) {
                        console.warn('ë°©ë²• 2 ì‹¤íŒ¨:', method2Error);
                        
                        try {
                            // ë°©ë²• 3: ì‘ì€ í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì¦ˆ í›„ ì²˜ë¦¬
                            console.log('ë°©ë²• 3 ì‹œë„: ì´ë¯¸ì§€ í¬ê¸° ì¶•ì†Œ');
                            const maxSize = 800;
                            let newWidth = width;
                            let newHeight = height;
                            
                            if (width > maxSize || height > maxSize) {
                                const ratio = Math.min(maxSize / width, maxSize / height);
                                newWidth = Math.floor(width * ratio);
                                newHeight = Math.floor(height * ratio);
                                
                                // Canvasë¡œ ë¦¬ì‚¬ì´ì¦ˆ
                                const resizeCanvas = document.createElement('canvas');
                                const resizeCtx = resizeCanvas.getContext('2d');
                                resizeCanvas.width = newWidth;
                                resizeCanvas.height = newHeight;
                                
                                const tempCanvas = document.createElement('canvas');
                                const tempCtx = tempCanvas.getContext('2d');
                                tempCanvas.width = width;
                                tempCanvas.height = height;
                                tempCtx.putImageData(imageData, 0, 0);
                                
                                resizeCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
                                
                                // ë¦¬ì‚¬ì´ì¦ˆëœ ì´ë¯¸ì§€ì—ì„œ Mat ìƒì„±
                                src = cv.imread(resizeCanvas);
                                console.log(`ë°©ë²• 3 ì„±ê³µ: ${width}x${height} â†’ ${newWidth}x${newHeight}`);
                            } else {
                                throw new Error('ì´ë¯¸ì§€ê°€ ì´ë¯¸ ì ì ˆí•œ í¬ê¸°ì…ë‹ˆë‹¤');
                            }
                        } catch (method3Error) {
                            console.error('ëª¨ë“  Mat ìƒì„± ë°©ë²• ì‹¤íŒ¨:', method3Error);
                            throw new Error('Mat ìƒì„± ë¶ˆê°€ëŠ¥ - OpenCV ë©”ëª¨ë¦¬ ë¬¸ì œ');
                        }
                    }
                }
                
                if (!src || src.empty()) {
                    throw new Error('ìƒì„±ëœ Matì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                }
                
                console.log('Mat ìƒì„± ì™„ë£Œ:', { rows: src.rows, cols: src.cols, type: src.type() });
                
                // ì‹¤ì œ ì²˜ë¦¬ í¬ê¸° ì €ì¥ (ë¦¬ì‚¬ì´ì¦ˆëœ ê²½ìš°ë¥¼ ìœ„í•´)
                const processWidth = src.cols;
                const processHeight = src.rows;
                const needsResize = (processWidth !== width || processHeight !== height);
                
                const gray = new cv.Mat();
                const blurred = new cv.Mat();
                const edges = new cv.Mat();
                const result = new cv.Mat();
                
                // 1. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
                console.log('1. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜ ì¤‘...');
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 2. ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ (ë…¸ì´ì¦ˆ ì œê±°)
                console.log('2. ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì ìš© ì¤‘...');
                const kernelSize = 5;
                cv.GaussianBlur(gray, blurred, new cv.Size(kernelSize, kernelSize), 1.4, 1.4);
                
                // 3. Canny ì—£ì§€ ê²€ì¶œ
                const lowThreshold = Math.max(10, threshold * 0.4);
                const highThreshold = Math.min(255, threshold * 1.2);
                console.log('3. Canny ì—£ì§€ ê²€ì¶œ ì¤‘...', { lowThreshold, highThreshold });
                cv.Canny(blurred, edges, lowThreshold, highThreshold);
                
                // 4. í˜•íƒœí•™ì  ì—°ì‚° (ì„  ì •ë¦¬)
                console.log('4. í˜•íƒœí•™ì  ì—°ì‚° ì ìš© ì¤‘...', { lineWidth });
                if (lineWidth > 1) {
                    const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(lineWidth, lineWidth));
                    cv.dilate(edges, result, kernel);
                    kernel.delete();
                } else {
                    edges.copyTo(result);
                }
                
                // 5. ìƒ‰ìƒ ë°˜ì „ (ê²€ì€ ë°°ê²½ì— í° ì„  â†’ í° ë°°ê²½ì— ê²€ì€ ì„ )
                console.log('5. ìƒ‰ìƒ ë°˜ì „ ì¤‘...');
                cv.bitwise_not(result, result);
                
                // 6. ì»¬ëŸ¬ ì´ë¯¸ì§€ë¡œ ë³€í™˜
                console.log('6. ì»¬ëŸ¬ ë³€í™˜ ì¤‘...');
                const colorResult = new cv.Mat();
                cv.cvtColor(result, colorResult, cv.COLOR_GRAY2RGBA);
                
                // 7. ì›ë³¸ í¬ê¸°ë¡œ ë³µì› (í•„ìš”í•œ ê²½ìš°)
                let finalResult = colorResult;
                if (needsResize) {
                    console.log(`7. ì›ë³¸ í¬ê¸°ë¡œ ë³µì› ì¤‘: ${processWidth}x${processHeight} â†’ ${width}x${height}`);
                    finalResult = new cv.Mat();
                    const dsize = new cv.Size(width, height);
                    cv.resize(colorResult, finalResult, dsize, 0, 0, cv.INTER_LINEAR);
                    colorResult.delete(); // ì„ì‹œ ê²°ê³¼ ì‚­ì œ
                }
                
                // Matì„ ImageDataë¡œ ì•ˆì „í•˜ê²Œ ë³€í™˜
                console.log('8. ImageDataë¡œ ë³€í™˜ ì¤‘...');
                let outputImageData;
                try {
                    // Mat ë°ì´í„° í¬ê¸° ê²€ì¦
                    const expectedSize = width * height * 4; // RGBA
                    if (finalResult.data.length !== expectedSize) {
                        throw new Error(`Mat ë°ì´í„° í¬ê¸° ë¶ˆì¼ì¹˜: ì˜ˆìƒ ${expectedSize}, ì‹¤ì œ ${finalResult.data.length}`);
                    }
                    
                    // ì•ˆì „í•œ ë°ì´í„° ë³µì‚¬
                    const outputData = new Uint8ClampedArray(finalResult.data);
                    outputImageData = new ImageData(outputData, width, height);
                    
                    console.log('ImageData ë³€í™˜ ì™„ë£Œ:', { 
                        width: outputImageData.width, 
                        height: outputImageData.height, 
                        dataLength: outputImageData.data.length 
                    });
                } catch (conversionError) {
                    throw new Error('ImageData ë³€í™˜ ì¤‘ ì˜¤ë¥˜: ' + conversionError.message);
                }
                
                console.log('OpenCV ì²˜ë¦¬ ì™„ë£Œ!');
                
                // ì•ˆì „í•œ ë©”ëª¨ë¦¬ ì •ë¦¬
                console.log('9. ë©”ëª¨ë¦¬ ì •ë¦¬ ì¤‘...');
                try {
                    if (src && !src.isDeleted()) src.delete();
                    if (gray && !gray.isDeleted()) gray.delete();
                    if (blurred && !blurred.isDeleted()) blurred.delete();
                    if (edges && !edges.isDeleted()) edges.delete();
                    if (result && !result.isDeleted()) result.delete();
                    if (finalResult && finalResult !== colorResult && !finalResult.isDeleted()) finalResult.delete();
                    // colorResultëŠ” finalResultì™€ ê°™ê±°ë‚˜ ì´ë¯¸ ì‚­ì œë¨
                } catch (deleteError) {
                    console.warn('ë©”ëª¨ë¦¬ ì •ë¦¬ ì¤‘ ê²½ê³ :', deleteError);
                }
                
                return outputImageData;
                
            } catch (error) {
                console.error('OpenCV ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
                
                // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œë„
                try {
                    if (typeof src !== 'undefined' && src && !src.isDeleted()) src.delete();
                    if (typeof gray !== 'undefined' && gray && !gray.isDeleted()) gray.delete();
                    if (typeof blurred !== 'undefined' && blurred && !blurred.isDeleted()) blurred.delete();
                    if (typeof edges !== 'undefined' && edges && !edges.isDeleted()) edges.delete();
                    if (typeof result !== 'undefined' && result && !result.isDeleted()) result.delete();
                    if (typeof colorResult !== 'undefined' && colorResult && !colorResult.isDeleted()) colorResult.delete();
                    if (typeof finalResult !== 'undefined' && finalResult && finalResult !== colorResult && !finalResult.isDeleted()) finalResult.delete();
                } catch (cleanupError) {
                    console.warn('ì˜¤ë¥˜ ì‹œ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤íŒ¨:', cleanupError);
                }
                
                // ê¸°ë³¸ ì²˜ë¦¬ë¡œ í´ë°±
                return applyBasicProcessing(imageData, threshold, lineWidth);
            }
        }

        function applyBasicProcessing(imageData, threshold, lineWidth) {
            const data = new Uint8ClampedArray(imageData.data);
            const width = imageData.width;
            const height = imageData.height;

            // 1. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }

            // 2. ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì ìš© (ë…¸ì´ì¦ˆ ì œê±°)
            const blurred = applyGaussianBlur(data, width, height, 1.0);

            // 3. ê°œì„ ëœ ì—£ì§€ ê²€ì¶œ (Canny-like)
            const edges = applyCannyllikeEdgeDetection(blurred, width, height, threshold);

            // 4. í˜•íƒœí•™ì  ì—°ì‚° (ì„  ì •ë¦¬)
            const cleaned = applyMorphologicalOperations(edges, width, height);

            // 5. ì„  êµµê¸° ì ìš©
            let final = cleaned;
            if (lineWidth > 1) {
                final = applyLineThickening(cleaned, width, height, lineWidth);
            }

            return new ImageData(final, width, height);
        }

        function applyGaussianBlur(data, width, height, sigma) {
            const blurred = new Uint8ClampedArray(data.length);
            const kernelSize = Math.ceil(sigma * 3) * 2 + 1;
            const kernel = [];
            const center = Math.floor(kernelSize / 2);
            
            // ê°€ìš°ì‹œì•ˆ ì»¤ë„ ìƒì„±
            let sum = 0;
            for (let i = 0; i < kernelSize; i++) {
                const x = i - center;
                const value = Math.exp(-(x * x) / (2 * sigma * sigma));
                kernel[i] = value;
                sum += value;
            }
            
            // ì •ê·œí™”
            for (let i = 0; i < kernelSize; i++) {
                kernel[i] /= sum;
            }

            // ìˆ˜í‰ ë¸”ëŸ¬
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const px = Math.max(0, Math.min(width - 1, x + k - center));
                        const idx = (y * width + px) * 4;
                        value += data[idx] * kernel[k];
                    }
                    const idx = (y * width + x) * 4;
                    blurred[idx] = blurred[idx + 1] = blurred[idx + 2] = Math.round(value);
                    blurred[idx + 3] = 255;
                }
            }

            // ìˆ˜ì§ ë¸”ëŸ¬
            const result = new Uint8ClampedArray(data.length);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    for (let k = 0; k < kernelSize; k++) {
                        const py = Math.max(0, Math.min(height - 1, y + k - center));
                        const idx = (py * width + x) * 4;
                        value += blurred[idx] * kernel[k];
                    }
                    const idx = (y * width + x) * 4;
                    result[idx] = result[idx + 1] = result[idx + 2] = Math.round(value);
                    result[idx + 3] = 255;
                }
            }

            return result;
        }

        function applyCannyllikeEdgeDetection(data, width, height, threshold) {
            const edges = new Uint8ClampedArray(data.length);
            
            // Sobel ì—°ì‚°ì
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
            
            const gradients = [];
            const directions = [];

            // ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            const intensity = data[idx];
                            gx += intensity * sobelX[dy + 1][dx + 1];
                            gy += intensity * sobelY[dy + 1][dx + 1];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const direction = Math.atan2(gy, gx);
                    
                    gradients[y * width + x] = magnitude;
                    directions[y * width + x] = direction;
                }
            }

            // Non-maximum suppression (ê°„ì†Œí™”ëœ ë²„ì „)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const magnitude = gradients[y * width + x] || 0;
                    
                    if (magnitude > threshold) {
                        // ì¸ì ‘ í”½ì…€ê³¼ ë¹„êµí•˜ì—¬ ê·¹ê°’ì¸ì§€ í™•ì¸
                        const neighbors = [
                            gradients[(y-1) * width + (x-1)] || 0,
                            gradients[(y-1) * width + x] || 0,
                            gradients[(y-1) * width + (x+1)] || 0,
                            gradients[y * width + (x-1)] || 0,
                            gradients[y * width + (x+1)] || 0,
                            gradients[(y+1) * width + (x-1)] || 0,
                            gradients[(y+1) * width + x] || 0,
                            gradients[(y+1) * width + (x+1)] || 0
                        ];
                        
                        const isLocalMax = neighbors.every(n => magnitude >= n);
                        
                        if (isLocalMax) {
                            edges[idx] = edges[idx + 1] = edges[idx + 2] = 0; // ê²€ì€ìƒ‰ (ì—£ì§€)
                        } else {
                            edges[idx] = edges[idx + 1] = edges[idx + 2] = 255; // í°ìƒ‰
                        }
                    } else {
                        edges[idx] = edges[idx + 1] = edges[idx + 2] = 255; // í°ìƒ‰
                    }
                    edges[idx + 3] = 255; // ì•ŒíŒŒ
                }
            }

            return edges;
        }

        function applyMorphologicalOperations(data, width, height) {
            // ì¹¨ì‹(erosion) í›„ íŒ½ì°½(dilation)ìœ¼ë¡œ ë…¸ì´ì¦ˆ ì œê±°
            const eroded = applyErosion(data, width, height);
            const dilated = applyDilation(eroded, width, height);
            return dilated;
        }

        function applyErosion(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // 3x3 ì»¤ë„ì—ì„œ ëª¨ë“  í”½ì…€ì´ ê²€ì€ìƒ‰ì¸ì§€ í™•ì¸
                    let allBlack = true;
                    for (let dy = -1; dy <= 1 && allBlack; dy++) {
                        for (let dx = -1; dx <= 1 && allBlack; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            if (data[nIdx] > 128) allBlack = false;
                        }
                    }
                    
                    if (allBlack) {
                        result[idx] = result[idx + 1] = result[idx + 2] = 0;
                    } else {
                        result[idx] = result[idx + 1] = result[idx + 2] = 255;
                    }
                    result[idx + 3] = 255;
                }
            }
            return result;
        }

        function applyDilation(data, width, height) {
            const result = new Uint8ClampedArray(data.length);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // 3x3 ì»¤ë„ì—ì„œ í•˜ë‚˜ë¼ë„ ê²€ì€ìƒ‰ì´ë©´ ê²€ì€ìƒ‰ìœ¼ë¡œ
                    let hasBlack = false;
                    for (let dy = -1; dy <= 1 && !hasBlack; dy++) {
                        for (let dx = -1; dx <= 1 && !hasBlack; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            if (data[nIdx] < 128) hasBlack = true;
                        }
                    }
                    
                    if (hasBlack) {
                        result[idx] = result[idx + 1] = result[idx + 2] = 0;
                    } else {
                        result[idx] = result[idx + 1] = result[idx + 2] = 255;
                    }
                    result[idx + 3] = 255;
                }
            }
            return result;
        }

        function applyLineThickening(data, width, height, lineWidth) {
            const result = new Uint8ClampedArray(data.length);
            
            // í°ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
            for (let i = 0; i < result.length; i += 4) {
                result[i] = result[i + 1] = result[i + 2] = 255;
                result[i + 3] = 255;
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    if (data[idx] < 128) { // ê²€ì€ìƒ‰ í”½ì…€ì´ë©´
                        // ì›í˜• ë¸ŒëŸ¬ì‹œë¡œ êµµê²Œ ë§Œë“¤ê¸°
                        for (let dy = -lineWidth; dy <= lineWidth; dy++) {
                            for (let dx = -lineWidth; dx <= lineWidth; dx++) {
                                const newX = x + dx;
                                const newY = y + dy;
                                
                                if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance <= lineWidth) {
                                        const newIdx = (newY * width + newX) * 4;
                                        result[newIdx] = result[newIdx + 1] = result[newIdx + 2] = 0;
                                        result[newIdx + 3] = 255;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return result;
        }

        function addColoringGuide(ctx, width, height, originalImage, paperName, orientation) {
            // ìƒ‰ì¹  ê°€ì´ë“œ í¬ê¸° ì„¤ì • (ì „ì²´ í¬ê¸°ì˜ 1/4 ì •ë„)
            const guideSize = Math.min(width, height) * 0.25;
            const guideWidth = guideSize;
            const guideHeight = guideSize * (originalImage.height / originalImage.width);
            
            // ìš°ì¸¡ ìƒë‹¨ì— ìœ„ì¹˜
            const guideX = width - guideWidth - 20;
            const guideY = 20;
            
            // ê°€ì´ë“œ ë°°ê²½ (í°ìƒ‰)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(guideX - 5, guideY - 5, guideWidth + 10, guideHeight + 35);
            
            // ê°€ì´ë“œ í…Œë‘ë¦¬
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(guideX - 5, guideY - 5, guideWidth + 10, guideHeight + 35);
            
            // ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ìƒ‰ì¹  ê°€ì´ë“œ)
            ctx.drawImage(originalImage, guideX, guideY, guideWidth, guideHeight);
            
            // ì´ë¯¸ì§€ í…Œë‘ë¦¬
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(guideX, guideY, guideWidth, guideHeight);
            
            // ê°€ì´ë“œ ë ˆì´ë¸”
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ìƒ‰ì¹  ê°€ì´ë“œ', guideX + guideWidth / 2, guideY + guideHeight + 20);
            
            // ì¢…ì´ ì •ë³´ (ì¢Œì¸¡ í•˜ë‹¨)
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            const infoText = `${paperName} | ${orientation === 'portrait' ? 'ì„¸ë¡œ' : 'ê°€ë¡œ'} | ${new Date().toLocaleDateString('ko-KR')}`;
            ctx.fillText(infoText, 20, height - 10);
            
            // ë„¤ ëª¨ì„œë¦¬ì— ìë¥´ê¸° ê°€ì´ë“œ
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            const markSize = 10;
            const margin = 5;
            
            [[margin, margin], [width - margin, margin], [margin, height - margin], [width - margin, height - margin]].forEach(([x, y]) => {
                ctx.beginPath();
                ctx.moveTo(x - markSize, y);
                ctx.lineTo(x + markSize, y);
                ctx.moveTo(x, y - markSize);
                ctx.lineTo(x, y + markSize);
                ctx.stroke();
            });
            
            // í…ìŠ¤íŠ¸ ì •ë ¬ ì´ˆê¸°í™”
            ctx.textAlign = 'left';
        }

        // showResult, downloadResult, resetApp í•¨ìˆ˜ ì œê±°ë¨ - ìƒˆë¡œìš´ UIì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ

        console.log('ì•± ë¡œë“œ ì™„ë£Œ');
    </script>
</body>
</html>